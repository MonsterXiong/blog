(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{579:function(s,t,a){"use strict";a.r(t);var e=a(26),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[s._v("#")]),s._v(" 持久化")]),s._v(" "),a("ul",[a("li",[s._v("默认情况下 Redis 是将数据保存在内存中的，保存在内存中的数据有一个特点，那就是机器重启之后数据就会丢失。")]),s._v(" "),a("li",[s._v("所以为了避免服务器重启死机等问题发生的时候，Redis 中保存的数据丢失 ，Redis 提供了数据持久化功能")])]),s._v(" "),a("p",[s._v("什么是数据持久化？")]),s._v(" "),a("ul",[a("li",[s._v("数据持久化就是将内存中的数据写入磁盘中")]),s._v(" "),a("li",[s._v("Redis 和大部分主流数据库(MySQL/MongoDB/...)一样，支持 RDB 和 AOF 持久化")])]),s._v(" "),a("h2",{attrs:{id:"rdb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[s._v("#")]),s._v(" RDB")]),s._v(" "),a("p",[s._v("Redis DataBase：持久化内存数据到磁盘")]),s._v(" "),a("p",[s._v("Redis 服务端 fork 一个子进程，定时并且达到触发修改次数的时候写磁盘，写到 RDB 文件。")]),s._v(" "),a("h3",{attrs:{id:"如何生成-rdb-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何生成-rdb-文件"}},[s._v("#")]),s._v(" 如何生成 RDB 文件")]),s._v(" "),a("p",[s._v("触发生成 RDB 三种机制")]),s._v(" "),a("ul",[a("li",[s._v("手动执行 save 命令\n"),a("ul",[a("li",[s._v("同步执行")]),s._v(" "),a("li",[s._v("如果已经存在旧的 RDB 文件，会利用新的覆盖旧的")]),s._v(" "),a("li",[s._v("多次执行会先在临时文件保存然后再进行覆盖")])])]),s._v(" "),a("li",[s._v("手动执行 bgsave 命令\n"),a("ul",[a("li",[s._v("异步执行")]),s._v(" "),a("li",[s._v("如果已经存在就的 RDB 文件，会利用新的覆盖旧的")])])]),s._v(" "),a("li",[s._v("通过配置文件自动生成\n"),a("ul",[a("li",[s._v("通过配置文件指定自动生成条件，一旦满足条件就会自动执行 bgsave 生成 RDB 文件")])])])]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" ./ "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#RDB文件保存的路径")]),s._v("\ndbfilename dump.rdb "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#RDB文件的名称")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# save 900 1 #自动生成条件")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# save 300 10")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# save 60 10000")]),s._v("\nstop-writes-on-bgsave-error "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#bgsave发生错误是否停止写入")]),s._v("\nrdbcompression "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#是否采用压缩模式写入")]),s._v("\nrdbchecksum "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#是否对生成的RDB文件进行校验")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 自动生成弊端")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 无法控制生成的频率，如果频率过高会导致性能消耗较大")]),s._v("\n")])])]),a("h3",{attrs:{id:"rdb-推荐配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb-推荐配置"}},[s._v("#")]),s._v(" RDB 推荐配置")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" /rdbdiskpath                "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#由于备份是比较占用磁盘空的, 所以推荐使用一个比较大的磁盘路径")]),s._v("\ndbfilename dump-"),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("${prot}")]),s._v(".rdb     "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#由于一台服务器上可能部署多个Redis, 所以可以给RDB文件添加端口号作为区分")]),s._v("\nstop-writes-on-bgsave-error "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#bgsave发生错误是否停止写入")]),s._v("\nrdbcompression "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("              "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#是否采用压缩模式写入")]),s._v("\nrdbchecksum "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("                 "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#是否对生成的RDB文件进行校验")]),s._v("\n")])])]),a("h3",{attrs:{id:"rdb-存在的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb-存在的问题"}},[s._v("#")]),s._v(" RDB 存在的问题")]),s._v(" "),a("ul",[a("li",[s._v("不可控、数据丢失\n"),a("ul",[a("li",[s._v("服务器当即之前的数据，如果未写入 RDB 文件就会丢失")])])])]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" name monster\nsave  or basave  or 自动保存\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" name zs\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 宕机")]),s._v("\n")])])]),a("ul",[a("li",[s._v("耗时、耗性能\n"),a("ul",[a("li",[s._v("RDB 是一次性把内存中所有的内容写入磁盘中，是一个 比较重的操作，如果需要写入的数据比较多，那么就比较耗时")]),s._v(" "),a("li",[s._v("RDB 每次都是把内存中的 所有内容 全部写入到磁盘中，哪怕内存中的数据已经写入过了也会再次完整写入，重复写入相同的 数据，也比较浪费 I/O 资源")]),s._v(" "),a("li",[s._v("如果通过 save 命令写入，会阻塞后续命令执行。如果通过 bgsave 写入，不会阻塞后续命令执行 ，会开启子进程去专门负责写入，但是开启子进程会消耗内存空间")])])])]),s._v(" "),a("h2",{attrs:{id:"aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[s._v("#")]),s._v(" AOF")]),s._v(" "),a("p",[s._v("Append Only File：持久化修改数据的命令")]),s._v(" "),a("p",[s._v("由客户端发起修改命令到 Redis 服务端，每秒/每个命令/不同步的方式到 AOF 文件。")]),s._v(" "),a("h3",{attrs:{id:"如何生成-aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何生成-aof"}},[s._v("#")]),s._v(" 如何生成 AOF")]),s._v(" "),a("ul",[a("li",[s._v("always\n"),a("ul",[a("li",[s._v("每条命令都写入一条命令到文件中")]),s._v(" "),a("li",[s._v("优点：不会 丢失数据")]),s._v(" "),a("li",[s._v("缺点：磁盘 I/O 消耗较大")])])]),s._v(" "),a("li",[s._v("everysec\n"),a("ul",[a("li",[s._v("每隔一秒写入一次，也就是先收集 1 秒钟的命令，然后再一次性写入到文件中")]),s._v(" "),a("li",[s._v("优点：磁盘 I/O 消耗相对较小")]),s._v(" "),a("li",[s._v("缺点：可能丢失 1 秒数据")])])]),s._v(" "),a("li",[s._v("no\n"),a("ul",[a("li",[s._v("让操作系统决定什么时候写入，操作系统想什么时候写入就什么什么 时候写入")]),s._v(" "),a("li",[s._v("不可控，可能丢失大量数据")])])])]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 配置文件中")]),s._v("\nappendfsync everysec\n")])])]),a("h3",{attrs:{id:"aof-重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写"}},[s._v("#")]),s._v(" AOF 重写")]),s._v(" "),a("ul",[a("li",[s._v("随着时间的推移 AOF 文件会越来越大，会带来以下问题\n"),a("ul",[a("li",[s._v("磁盘消耗越来越大")]),s._v(" "),a("li",[s._v("写入速度会越来越慢")]),s._v(" "),a("li",[s._v("恢复的时间越来越慢")])])]),s._v(" "),a("li",[s._v("所以 AOF 提供了重写的机制，我们可以对 AOF 文件中保存的内容进行优化\n"),a("ul",[a("li",[s._v("从而降低文件的体积")]),s._v(" "),a("li",[s._v("从而提升文件的恢复速度")])])]),s._v(" "),a("li",[s._v("在 AOF 的重写机制中\n"),a("ul",[a("li",[s._v("可以将自动去除冗余命令")]),s._v(" "),a("li",[s._v("可以自动删除没有用的命令")])])])]),s._v(" "),a("div",{staticClass:"language-diff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-diff"}},[a("code",[a("span",{pre:!0,attrs:{class:"token inserted-sign inserted"}},[a("span",{pre:!0,attrs:{class:"token prefix inserted"}},[s._v("+")]),a("span",{pre:!0,attrs:{class:"token line"}},[s._v(" 优化前：set name monster; set name zs;set name ls;\n")]),a("span",{pre:!0,attrs:{class:"token prefix inserted"}},[s._v("+")]),a("span",{pre:!0,attrs:{class:"token line"}},[s._v(" 优化后：set name ls;\n")]),a("span",{pre:!0,attrs:{class:"token prefix inserted"}},[s._v("+")]),a("span",{pre:!0,attrs:{class:"token line"}},[s._v(" 优化前：incr conunt;incr count;\n")]),a("span",{pre:!0,attrs:{class:"token prefix inserted"}},[s._v("+")]),a("span",{pre:!0,attrs:{class:"token line"}},[s._v(" 优化后：set count 2;\n")]),a("span",{pre:!0,attrs:{class:"token prefix inserted"}},[s._v("+")]),a("span",{pre:!0,attrs:{class:"token line"}},[s._v(" 优化前：expire name 3\n")]),a("span",{pre:!0,attrs:{class:"token prefix inserted"}},[s._v("+")]),a("span",{pre:!0,attrs:{class:"token line"}},[s._v(" 优化后：3秒后由于数据已经被删除，所以这条命令不用保存\n")])]),s._v("\n")])])]),a("h3",{attrs:{id:"触发-aof-重写两种机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发-aof-重写两种机制"}},[s._v("#")]),s._v(" 触发 AOF 重写两种机制")]),s._v(" "),a("ul",[a("li",[s._v("bgrewriteaof 命令\n"),a("ul",[a("li",[s._v("开启一个新的子进程，根据内容中的数据生成命令写入到 AOF 文件中")])])]),s._v(" "),a("li",[s._v("配置文件设置")])]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("auto-aof-rewrite-min-size 200mb "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#AOF文件体积达到多大时进行重写")]),s._v("\nauto-aof-rewrite-percentage "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#对比上一次重写否，增长了百分之多少再次进行重写")]),s._v("\n\t\t\t\t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#例如上一次重写大小后是100MB，如果设置50，那么下一次就是增长0.5倍（150）再重写")]),s._v("\n\t\t\t\t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#例如上一次重写大小是100MB，如果设置100，那么下一次就是增长两倍（200）再重写")]),s._v("\n")])])]),a("h3",{attrs:{id:"aof-推荐配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-推荐配置"}},[s._v("#")]),s._v(" AOF 推荐配置")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("appendonly "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("                           "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#是否使用AOF")]),s._v("\nappendfilename "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"appendonly-'),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("${prot}")]),s._v('.aof"')]),s._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#AOF文件名称")]),s._v("\nappendfsync everysec                     "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#写入命令的同步机制")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" /rdbdiskpath                         "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#保存AOF文件路径")]),s._v("\nauto-aof-rewrite-min-size 64mb           "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#AOF文件重写体积")]),s._v("\nauto-aof-rewrite-percentage "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),s._v("          "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#AOF文件增长率")]),s._v("\nno-appendfsync-on-rewrite "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("            "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#AOF重写时是否正常写入当前操作的命令(追求性能yes，追求数据安全性no)")]),s._v("\n")])])]),a("h2",{attrs:{id:"rdb-vs-aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb-vs-aof"}},[s._v("#")]),s._v(" RDB vs AOF")]),s._v(" "),a("table",[a("thead",[a("tr",[a("th"),s._v(" "),a("th",[s._v("RDB")]),s._v(" "),a("th",[s._v("AOF")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("保存内容")]),s._v(" "),a("td",[s._v("二进制数据文件")]),s._v(" "),a("td",[s._v("Redis 命令")])]),s._v(" "),a("tr",[a("td",[s._v("数据恢复速度")]),s._v(" "),a("td",[s._v("快照恢复速度快")]),s._v(" "),a("td",[s._v("命令过多速度慢")])]),s._v(" "),a("tr",[a("td",[s._v("数据恢复完整性")]),s._v(" "),a("td",[s._v("可能丢数据")]),s._v(" "),a("td",[s._v("比 RDB 高")])])])]),s._v(" "),a("ul",[a("li",[s._v("AOF 优先级高于 RDB\n"),a("ul",[a("li",[s._v("如果 Redis 服务器同时开启了 RDB 和 AOF, 那么宕机重启之后会优先从 AOF 中恢复数据")])])]),s._v(" "),a("li",[s._v("RDB 体积小于 AOF\n"),a("ul",[a("li",[s._v("由于 RDB 在备份的时候会对数据进行压缩, 而 AOF 是逐条保存命令, 所以 RDB 体积比 AOF 小")])])]),s._v(" "),a("li",[s._v("RDB 恢复速度比 AOF 恢复速度快\n"),a("ul",[a("li",[s._v("由于 AOF 是通过逐条执行命令的方式恢复数据, 而 RDB 是通过加载预先保存的数据恢复数据\n所以 RDB 的恢复速度比 AOF 快")])])]),s._v(" "),a("li",[s._v("AOF 数据安全性高于 RDB\n"),a("ul",[a("li",[s._v("由于 AOF 可以逐条写入命令, 而 RDB 只能定期备份数据, 所以 AOF 数据安全性高于 RDB")])])]),s._v(" "),a("li",[s._v("所以综上所述, 两者各有所长, 两者不是替代关系而是互补关系")])]),s._v(" "),a("h2",{attrs:{id:"如何能够最大化保证恢复数据的速度及数据的完整性呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何能够最大化保证恢复数据的速度及数据的完整性呢"}},[s._v("#")]),s._v(" 如何能够最大化保证恢复数据的速度及数据的完整性呢？")]),s._v(" "),a("p",[s._v("Redis4.0 以后推出混合持久化的方式，以 RDB 的方式全量持久化内存数据，保证数据恢复的速度并以增量的方式持久化修改命令，保证数据的完整性。最终以 RDB 和 AOF 共存的方式写入 AOF 文件。")])])}),[],!1,null,null,null);t.default=n.exports}}]);