(window.webpackJsonp=window.webpackJsonp||[]).push([[200],{582:function(s,t,e){"use strict";e.r(t);var a=e(26),r=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"redis-架构模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-架构模式"}},[s._v("#")]),s._v(" Redis 架构模式")]),s._v(" "),e("h2",{attrs:{id:"单机模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单机模式"}},[s._v("#")]),s._v(" 单机模式")]),s._v(" "),e("p",[s._v("指的是缓存服务中只有一台 Redis 对我们的应用提供读写服务，因为只有一台 Redis，缺点比较明显，Redis 宕机时应用就无法使用，并且只有一台 Redis，吞吐量比较低。")]),s._v(" "),e("h2",{attrs:{id:"主从模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从模式"}},[s._v("#")]),s._v(" 主从模式")]),s._v(" "),e("p",[s._v("指的是缓存服务中有一台主和多台从 Redis，主 Redis 提供写，从 Redis 提供读，实现读写分离，减轻单台 Redis 的压力，但是主 Redis 宕机时，需要手动去选择从 Redis，也是不可用的。")]),s._v(" "),e("h2",{attrs:{id:"哨兵模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式"}},[s._v("#")]),s._v(" 哨兵模式")]),s._v(" "),e("p",[s._v("指的是缓存服务中仍然有主从 Redis 对外提供服务，并且有哨兵去监控主从 Redis 的状态，如果主 Redis 发生宕机，就会从从 Redis 中自动选择一台对外提供服务，这种模式可以解决可用性问题，但是只有一台 Redis 对外提供写服务，大量写仍然会有问题，所以引入集群模式解决可用性和吞吐量大的问题。")]),s._v(" "),e("h2",{attrs:{id:"集群模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集群模式"}},[s._v("#")]),s._v(" 集群模式")]),s._v(" "),e("p",[s._v("是通过多个独立的主从 Redis 对外提供服务，解决可用和吞吐量问题，但应用具体读写哪一台主从，集群模式下有 16384 个 hash slot 分别分布在主从上，根据 key 计算出哈希槽的位置确定在哪一个主从。")])])}),[],!1,null,null,null);t.default=r.exports}}]);