(window.webpackJsonp=window.webpackJsonp||[]).push([[229],{610:function(T,v,_){"use strict";_.r(v);var t=_(26),P=Object(t.a)({},(function(){var T=this,v=T.$createElement,_=T._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":T.$parent.slotKey}},[_("h1",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[T._v("#")]),T._v(" HTTP")]),T._v(" "),_("p",[T._v("HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最广泛的一种网络传输协议，HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件，图片文件，查询结果等）。")]),T._v(" "),_("h2",{attrs:{id:"http-简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-简介"}},[T._v("#")]),T._v(" HTTP 简介")]),T._v(" "),_("p",[T._v("是用于从万维网服务器传输超文本到本地浏览器的传送协议。")]),T._v(" "),_("h2",{attrs:{id:"http-工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-工作原理"}},[T._v("#")]),T._v(" HTTP 工作原理")]),T._v(" "),_("p",[T._v("HTTP 协议工作于客户端-服务端架构上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。")]),T._v(" "),_("p",[T._v("WEB 服务器根据收到的请求后，向客户端发送响应信息。")]),T._v(" "),_("p",[T._v("HTTP 默认端口号为 80，但是你也可以改为 8080 或者其他端口。")]),T._v(" "),_("p",[T._v("HTTP 三点注意事项（特性）")]),T._v(" "),_("ul",[_("li",[T._v("HTTP 是无连接的：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。")]),T._v(" "),_("li",[T._v("HTTP 是媒体独立的：这意味着，只要客户端和服务端知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送，客户端以及服务器指定使用适合的 MIME-type 内容类型。")]),T._v(" "),_("li",[T._v("HTTP 是无状态的：HTTP 协议是无状态协议。无状态协议是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。")])]),T._v(" "),_("p",[_("img",{attrs:{src:"http://img.monsterbear.top/img/HTTP%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png",alt:"Snipaste_2021-05-19_16-50-21"}})]),T._v(" "),_("p",[T._v("CGI（Common Gateway Interface）是 HTTP 服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序必须运行在网络服务器上。")]),T._v(" "),_("p",[T._v("绝大多数的 CGI 程序被用来解释处理来自表单的输入信息，并在服务器产生相应的处理，或将相应的信息反馈给浏览器。CGI 程序使网页具有交互功能。")]),T._v(" "),_("p",[T._v("浏览器显示的内容都有 HTML、XML、GIF、Flash 等，浏览器是通过 MIME Type 区分它们，决定用什么内容什么形式来显示。")]),T._v(" "),_("p",[T._v("注释：MIME Type 是该资源的媒体类型，MIME Type 不是个人指定的，是经过互联网（IETF）组织协商，以 RFC（一系列以编号排定的文件，几乎所有的互联网标准都会收录在其中）的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范（Emial 附件的类型也是通过 MIME Type 指定的）。")]),T._v(" "),_("p",[T._v("媒体类型通常通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的。例如："),_("code",[T._v("Content-type:text/HTML")]),T._v("。")]),T._v(" "),_("p",[T._v("通常只有一些卓越互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x-开头。")]),T._v(" "),_("h2",{attrs:{id:"http-消息结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-消息结构"}},[T._v("#")]),T._v(" HTTP 消息结构")]),T._v(" "),_("p",[T._v("HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。")]),T._v(" "),_("p",[T._v("一个 HTTP 客户端是一个应用程序（Web 浏览器或其他任何客户端），通过连接到服务器达到向多个服务器发送一个或多个 HTTP 的请求的目的。")]),T._v(" "),_("p",[T._v("一个 HTTP 服务器同样是一个应用程序（通常是一个 Web 服务），通过接收客户端的请求并向客户端发送 HTTP 响应数据。")]),T._v(" "),_("p",[T._v("HTTP 使用统一资源标识符（URI）来传输数据和建立连接。")]),T._v(" "),_("p",[T._v("一旦建立连接后，数据消息就通过类似 Internet 邮件所使用的格式和多用途 Internet 邮件扩展（MIME）来传送。")]),T._v(" "),_("h3",{attrs:{id:"客户端请求消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#客户端请求消息"}},[T._v("#")]),T._v(" 客户端请求消息")]),T._v(" "),_("p",[T._v("客户端发送一个 HTTP 请求到服务器的请求消息包括以下格式：请求行、请求头、空行和请求数据四个部分组成。")]),T._v(" "),_("p",[T._v("请求方法 空格 URL 空格 协议版本 回车符 换行符 --请求行")]),T._v(" "),_("p",[T._v("头部字段名：值 回车符 换行符")]),T._v(" "),_("p",[T._v("。。。")]),T._v(" "),_("p",[T._v("头部字段名：值 回车符 换行符 ---请求头部")]),T._v(" "),_("p",[T._v("回车符 换行符")]),T._v(" "),_("p",[T._v("--- 请求数据")]),T._v(" "),_("h3",{attrs:{id:"服务器响应消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务器响应消息"}},[T._v("#")]),T._v(" 服务器响应消息")]),T._v(" "),_("p",[T._v("HTTP 响应也有四部分组成，分别是：状态行、消息报头、空行和响应正文。")]),T._v(" "),_("h3",{attrs:{id:"http-请求方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-请求方法"}},[T._v("#")]),T._v(" HTTP 请求方法")]),T._v(" "),_("p",[T._v("根据 HTTP 标准，HTTP 请求可以使用多种请求方法。")]),T._v(" "),_("p",[T._v("HTTP1.0 定义了三种请求方法：GET，POST 和 HEAD 方法。")]),T._v(" "),_("p",[T._v("HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。")]),T._v(" "),_("p",[T._v("HTTP 协议中共定义了 9 种方法来表明对给定资源执行的操作，指示针对给定资源要执行的期望动作。")]),T._v(" "),_("ul",[_("li",[_("p",[T._v("GET：请求一个指定资源的表示形式。使用 GET 的请求应该只被用于获取数据。")])]),T._v(" "),_("li",[_("p",[T._v("HEAD：请求一个与 GET 请求的响应相同的响应，但没有响应体。用于获取报头。")])]),T._v(" "),_("li",[_("p",[T._v("POST：用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。")])]),T._v(" "),_("li",[_("p",[T._v("PUT：用于请求有效载荷替换目标资源的所有当前表示。")])]),T._v(" "),_("li",[_("p",[T._v("DELETE：删除指定的资源。")])]),T._v(" "),_("li",[_("p",[T._v("CONNECT：建立一个到有目标资源标识的服务器的隧道。")])]),T._v(" "),_("li",[_("p",[T._v("OPTIONS：用于描述目标资源的通信选项。")])]),T._v(" "),_("li",[_("p",[T._v("TRACE：沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。")])]),T._v(" "),_("li",[_("p",[T._v("PATCH：是对 PUT 方法的补充，用于对资源应用部分修改。")])])]),T._v(" "),_("p",[T._v("虽然 HTTP 请求方式有 8 种，但是我们在实际应用中最常用的也就是 get 和 post，其他请求方式都可以通过这两种方式间接的来实现。")]),T._v(" "),_("h3",{attrs:{id:"http-响应头信息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-响应头信息"}},[T._v("#")]),T._v(" HTTP 响应头信息")]),T._v(" "),_("h3",{attrs:{id:"http-状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[T._v("#")]),T._v(" HTTP 状态码")]),T._v(" "),_("p",[T._v("当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头用以响应浏览器的请求。")]),T._v(" "),_("p",[T._v("HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型。")]),T._v(" "),_("ul",[_("li",[T._v("1xx：信息，服务器收到请求，需要请求者继续执行操作。")]),T._v(" "),_("li",[T._v("2xx：成功，操作被成功接收并处理。")]),T._v(" "),_("li",[T._v("3xx：重定向，需要进一步的操作来完成请求。")]),T._v(" "),_("li",[T._v("4xx：客户端错误，请求包含语法错误或无法完成请求。")]),T._v(" "),_("li",[T._v("5xx：服务器错误，服务器在处理请求的过程中发生了错误。")])]),T._v(" "),_("p",[T._v("-- more")]),T._v(" "),_("h3",{attrs:{id:"http-content-type"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-content-type"}},[T._v("#")]),T._v(" HTTP Content-Type")]),T._v(" "),_("p",[T._v("Content-Type(内容类型)，一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。")]),T._v(" "),_("p",[T._v("Content-Type 标头告诉客户端实际返回的内容的内容类型。")]),T._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[T._v("Content-Type:text/html;charset=utf-8\n")])])]),_("p",[T._v("常见的媒体格式类型")]),T._v(" "),_("p",[T._v("以 application 开头的媒体格式类型")]),T._v(" "),_("p",[T._v("常见的媒体格式是上传文件之时使用的")]),T._v(" "),_("h2",{attrs:{id:"http-发展史"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-发展史"}},[T._v("#")]),T._v(" HTTP 发展史")]),T._v(" "),_("h3",{attrs:{id:"http-0-9"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-0-9"}},[T._v("#")]),T._v(" HTTP/0.9")]),T._v(" "),_("p",[T._v("HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。")]),T._v(" "),_("ul",[_("li",[T._v("因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 CP 协议三次握手的过程。")]),T._v(" "),_("li",[T._v("建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。")]),T._v(" "),_("li",[T._v("服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。")]),T._v(" "),_("li",[T._v("HTML 文档传输完成后，断开连接。")])]),T._v(" "),_("p",[_("strong",[T._v("HTTP/0.9 的请求流程")])]),T._v(" "),_("p",[T._v("构建请求=>通过 DNS 查询 IP 地址=>三次握手建立 TCP 连接=>客户端发起请求=>服务器响应=>四次挥手断开 TCP 连接")]),T._v(" "),_("p",[T._v("当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP/0.9 的实现有以下三个特点。")]),T._v(" "),_("ul",[_("li",[T._v("第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。")]),T._v(" "),_("li",[T._v("第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。")]),T._v(" "),_("li",[T._v("第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。")])]),T._v(" "),_("h3",{attrs:{id:"http-1-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[T._v("#")]),T._v(" HTTP/1.0")]),T._v(" "),_("p",[T._v("因为在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其它类型编码的文件。")]),T._v(" "),_("h4",{attrs:{id:"如何实现多种类型文件的下载呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何实现多种类型文件的下载呢"}},[T._v("#")]),T._v(" 如何实现多种类型文件的下载呢？")]),T._v(" "),_("p",[T._v("HTTP 是浏览器和服务器之间的通信语言，不过 HTTP/0.9 在建立好连接之后，只会发送类似 GET /index.html 的简单请求命令，并没有其他途径告诉服务器更多的信息，如文件编码、文件类型等。同样，服务器是直接返回数据给浏览器的，也没有其他途径告诉浏览器更多的关于服务器返回的文件信息。")]),T._v(" "),_("p",[T._v("所以这种简单的交流形式是不能满足传输多种类型文件的需求，为了让客户端和服务器能更深入的交流，HTTP/1.0 引入了请求头和响应头，它们都是以 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。")]),T._v(" "),_("p",[_("strong",[T._v("HTTP/1.0 的请求流程")])]),T._v(" "),_("p",[T._v("构建请求=>通过 DNS 查询 IP 地址=>三次握手建立 TCP 连接=>客户端发起请求（含请求头）=>服务器响应（含响应头）=>四次挥手断开 TCP 连接")]),T._v(" "),_("h4",{attrs:{id:"http-1-0-是怎么通过请求头和响应头来支持多种不同类型的数据呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-是怎么通过请求头和响应头来支持多种不同类型的数据呢"}},[T._v("#")]),T._v(" HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？")]),T._v(" "),_("p",[T._v("要支持多种类型的文件，我们就需要解决以下几个问题。")]),T._v(" "),_("ul",[_("li",[T._v("首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。")]),T._v(" "),_("li",[T._v("其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。")]),T._v(" "),_("li",[T._v("再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。")]),T._v(" "),_("li",[T._v("最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。")])]),T._v(" "),_("p",[T._v("基于以上问题，HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：")]),T._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[T._v("accept: text/html\naccept-encoding: gzip, deflate, br\naccept-Charset: ISO-8859-1,utf-8\naccept-language: zh-CN,zh``\n")])])]),_("p",[T._v("其中第一行表示期望服务器返回 html 类型的文件，第二行表示期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式，第三行表示期望返回的文件编码是 UTF-8 或者 ISO-8859-1,第四行是表示期望页面的优先语言是中文。")]),T._v(" "),_("p",[T._v("服务器接受到浏览器发送过来的请求信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。")]),T._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[T._v("content-encoding: br\ncontent-type: text/html;charset=UTF-8\n")])])]),_("p",[T._v("其中第一行表示服务器采用了 br 的压缩方法，第二行表示服务器返回的 html 文件，并且该文件的编码类型是 UTF-8。")]),T._v(" "),_("p",[T._v("有了响应头的信息，浏览器就会使用 br 方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。这就是 HTTP/1.0 支持多文件的一个基本的处理流程。")]),T._v(" "),_("p",[T._v("HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性：")]),T._v(" "),_("ul",[_("li",[T._v("有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。")]),T._v(" "),_("li",[T._v("为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。")]),T._v(" "),_("li",[T._v("服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段。")])]),T._v(" "),_("h3",{attrs:{id:"http-1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[T._v("#")]),T._v(" HTTP/1.1")]),T._v(" "),_("p",[T._v("随着技术的持续发展，需求也在不断迭代更新，很快 HTTP/1.0 也不能满足需求了，所以 HTTP/1.1 又在 HTTP/1.0 的基础之上做了大量的更新。")]),T._v(" "),_("ol",[_("li",[_("p",[T._v("改进持久连接")]),T._v(" "),_("p",[T._v("HTTP/1.0每进行一次HTTP通信，都需要经历建立TCP、传输HTTP数据和断开TCP连接三个阶段。")]),T._v(" "),_("p",[_("strong",[T._v("浏览器 建立TCP连接 HTTP请求 HTTP响应 断开TCP连接 建立TCP连接 HTTP请求 HTTP响应 断开TCP连接 服务器")])]),T._v(" "),_("p",[T._v("在当时，由于通信的文件比较小，而且每个页面的引用也不多，所以这种传输形式没什么大问题。但是随着浏览器普及，每个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立TCP连接、传输数据和断开连接这样的步骤，就会增加大量无谓的开销。")]),T._v(" "),_("p",[T._v("为了解决这个问题，HTTP/1.1中增加了持久连接的方法，它的特点是在一个TCP连接上可以传输多个HTTP请求，只要浏览器或者服务器没有明确断开连接那么该TCP连接会一直保持。")]),T._v(" "),_("p",[_("strong",[T._v("浏览器 建立TCP连接 HTTP请求1 HTTP响应1 HTTP请求2 HTTP响应2 断开TCP连接 服务器")])]),T._v(" "),_("p",[T._v("可以看出，HTTP持久连接可以有效减少TCP建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体HTTP的请求时长。")]),T._v(" "),_("p",[T._v("持久连接在HTTP/1.1中是默认开启的，所以不需要专门为了持久连接去HTTP请求头设置信息，如果不想采用持久连接，可以在HTTP请求头中加上Connection:close。目前浏览器中对于同一个域名，默认允许同时建立6个TCP持久连接。")])]),T._v(" "),_("li",[_("p",[T._v("不成熟的 HTTP 管线化")]),T._v(" "),_("p",[T._v("持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是队头阻塞的问题。")]),T._v(" "),_("p",[T._v("HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。")]),T._v(" "),_("p",[T._v("FireFox、Cheome 都做过管线化的实验，但是由于各种原因，它们最终都放弃了管线化技术。")])]),T._v(" "),_("li",[_("p",[T._v("提供虚拟主机的支持")]),T._v(" "),_("p",[T._v("在 HTTP/1.0 中，每个域名绑定了唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己单独的域名，这些单独的域名都公用同一个 IP 地址。")]),T._v(" "),_("p",[T._v("因此，HTTP/1.1 的请求头中增加了"),_("strong",[T._v("Host 字段")]),T._v("，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。")])]),T._v(" "),_("li",[_("p",[T._v("对动态生成的内容提供了完美支持")]),T._v(" "),_("p",[T._v("在设计 HTTP/1.0 时，需要在响应头设置完整的数据大小，如 Content-Length:901,这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。")]),T._v(" "),_("p",[T._v("HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。")])]),T._v(" "),_("li",[_("p",[T._v("客户端 Cookie、安全机制")]),T._v(" "),_("p",[T._v("除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。")])])]),T._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[T._v("#")]),T._v(" 总结")]),T._v(" "),_("p",[T._v("本文我们重点强调了 HTTP 是浏览器和服务器的通信语言，然后我们从需求演变的角度追溯了 HTTP 的发展史，在诞生之初的 HTTP/0.9 因为需求简单，所以和服务器之间的通信过程也相对简单。")]),T._v(" "),_("p",[T._v("由于万维网的快速崛起，带来了大量新的需求，其中最核心的一个就是需要支持多种类型的文件下载， 为此 HTTP/1.0 中引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP/1.0 还提供了 Cache 机制、用户代理、状态码等一些基础信息。")]),T._v(" "),_("p",[T._v("但随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于 HTTP/1.0 推出了 HTTP/1.1，增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率（不过由于各种原因，管线化技术最终被各大厂商放弃了）。除此之外，HTTP/1.1 还引入了 Cookie、虚拟主机的支持、对动态内容的支持等特性。")]),T._v(" "),_("p",[T._v("虽然 HTTP/1.1 在 HTTP/1.0 的基础之上做了大量的优化，但是由于一些效率问题始终很难解决，所以最终还是被 HTTP/2 所取代")]),T._v(" "),_("h3",{attrs:{id:"http2-如何提升网络速度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2-如何提升网络速度"}},[T._v("#")]),T._v(" HTTP2：如何提升网络速度？")]),T._v(" "),_("p",[T._v("HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：")]),T._v(" "),_("ol",[_("li",[T._v("增加持久连接；")]),T._v(" "),_("li",[T._v("浏览器为每个域名最多同时维护 6 个 TCP 持久连接。")]),T._v(" "),_("li",[T._v("使用 CDN 的实现域名分片机制")])]),T._v(" "),_("p",[T._v("浏览器 =>CDN1 => CDN2 =>CDNX")]),T._v(" "),_("p",[T._v("通过引入了 CND，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100"),_("em",[T._v("n")]),T._v("RTT;若通过上面的技术，就可以把整个时间缩短为 100"),_("em",[T._v("n")]),T._v("RTT/(6*CDN 个数)。这样页面加载速度变快了不少。")]),T._v(" "),_("p",[T._v("HTTP/1.1 的主要问题")]),T._v(" "),_("p",[T._v("虽然 HTTP 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP 对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题。")]),T._v(" "),_("p",[T._v("带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。")]),T._v(" "),_("p",[T._v("之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满，比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/s,很难将 12.5M 全部用满。")]),T._v(" "),_("p",[T._v("之所以会出现这个问题，主要是由以下三个原因导致的。")]),T._v(" "),_("p",[T._v("第一个原因，TCP 的慢启动。")]),T._v(" "),_("p",[T._v("一旦一个 TCP 连接建立之后，就进入发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。")]),T._v(" "),_("p",[T._v("你可以把每个 TCP 发送数据的过程看成是一辆车的启动过程，当刚进入公路时，会有从 0 到一个稳定速度的提速过程，TCP 的慢启动就类似于该过程。")]),T._v(" "),_("p",[T._v("慢启动是 TCP 为了减少网络堵塞的一种策略，我们是没有办法改变的。")]),T._v(" "),_("p",[T._v("而之所以慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通过这些文件在 TCP 连接建立好了之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。")]),T._v(" "),_("p",[T._v("第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。")]),T._v(" "),_("p",[T._v("系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接受速度会慢慢向上增加;而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6*3，也就是 18 个 TCP 连接来下载资源；在下载的过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。")]),T._v(" "),_("p",[T._v("这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响哪些关键资源的下载速度了。")]),T._v(" "),_("p",[T._v("第三个原因，HTTP/1.1 队头阻塞的问题。")]),T._v(" "),_("p",[T._v("HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。")]),T._v(" "),_("p",[T._v("这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。")]),T._v(" "),_("p",[T._v("在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。")]),T._v(" "),_("p",[T._v("但队头阻塞使得这些数据不能并行请求，所以队头阻塞很不利于浏览器优化。")]),T._v(" "),_("h4",{attrs:{id:"http-2-的多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-的多路复用"}},[T._v("#")]),T._v(" HTTP/2 的多路复用")]),T._v(" "),_("p",[T._v("慢启动和 TCP 之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。")]),T._v(" "),_("p",[T._v("虽然 TCP 有问题，但是我们依然没有换掉 TCP 的能力，所以我们就要想办法规避 TCP 的慢启动和 TCP 连接之间的竞争问题。")]),T._v(" "),_("p",[T._v("基于此，HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。")]),T._v(" "),_("p",[T._v("另外，就是队头阻塞的问题，等待请求完成后次啊能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。")]),T._v(" "),_("p",[T._v("所以，HTTP/2 的解决方案可以总结为：一个域名使用一个 TCP 长连接和消除队头阻塞问题。")]),T._v(" "),_("p",[_("img",{attrs:{src:"https://static001.geekbang.org/resource/image/0c/85/0c4cb2c742e503ad7f549d74d66cfe85.png",alt:""}})]),T._v(" "),_("p",[T._v("该图就是 HTTP/2 最核心、最重要且最具颠覆性的多路复用机制。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。")]),T._v(" "),_("p",[T._v("服务端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到了之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。")]),T._v(" "),_("p",[T._v("HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。")]),T._v(" "),_("h4",{attrs:{id:"多路复用的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用的实现"}},[T._v("#")]),T._v(" 多路复用的实现")]),T._v(" "),_("p",[T._v("HTTP/2 request-1 .... request-n => 二进制分帧层=>TLS(可选)=>TCP=>IP")]),T._v(" "),_("p",[T._v("HTTP/2 添加了一个二进制分帧层。HTTP/2 的请求和接收过程。")]),T._v(" "),_("ul",[_("li",[T._v("首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。")]),T._v(" "),_("li",[T._v("这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。")]),T._v(" "),_("li",[T._v("服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。")]),T._v(" "),_("li",[T._v("然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。")]),T._v(" "),_("li",[T._v("同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。")]),T._v(" "),_("li",[T._v("浏览器接受到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。")])]),T._v(" "),_("p",[T._v("通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。")]),T._v(" "),_("p",[T._v("HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP/2 引入了二进制分帧层，不过 HTTP/2 的语义和 HTTP/1.1 依然是一样的，也就是说他们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收什么类型的文件，依然可以使用 Cookie 来保持登陆状态，依然可以使用 Cache 来缓存本地文件，这些都有没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着我们不需要为 HTTP/2 来重建生态，并且 HTTP/2 推广起来会相对更轻松了。")]),T._v(" "),_("p",[T._v("HTTP/2 其他特性\n多路复用是 HTTP/2 最核心的功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实 基于二进制分帧层，HTTP/2 还附带实现了很多其他功能。")]),T._v(" "),_("ol",[_("li",[T._v("可以设置请求的优先级")])]),T._v(" "),_("p",[T._v("我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚些那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。")]),T._v(" "),_("p",[T._v("为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。")]),T._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[T._v("服务器推送")])]),T._v(" "),_("p",[T._v("除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。")]),T._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[T._v("头部压缩")])]),T._v(" "),_("p",[T._v("无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。")]),T._v(" "),_("h4",{attrs:{id:"总结-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[T._v("#")]),T._v(" 总结")]),T._v(" "),_("p",[T._v("影响 HTTP/1.1 效率的三个主要因素：TCP 的慢启动、多条 TCP 连接竞争带宽和对头阻塞。")]),T._v(" "),_("p",[T._v("HTTP/2 是采用多路复用机制来解决这些问题的。多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从而大大提升了文件传输效率。")]),T._v(" "),_("p",[T._v("HTTP/2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署。使用 HTTP/2 能带来 20%~60%的效率提升，至于 20%还是 60%要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP/1.1 和其性能优化方法，去“拥抱”HTTP/2。")]),T._v(" "),_("p",[T._v("虽然 HTTP/2 解决了 HTTP/1.1 中的队头阻塞问题，但是 HTTP/2 依然是基于 TCP 协议的，而 TCP 协议依然存在数据包级别的队头阻塞问题。，TCP 的队头阻塞是如何影响到 HTTP/2 性能的。")]),T._v(" "),_("h3",{attrs:{id:"http3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http3"}},[T._v("#")]),T._v(" HTTP3")]),T._v(" "),_("p",[T._v("HTTP2 的一个核心特性是使用了多路复用技术，因此它可以通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题，同时还实现了头部压缩、服务器推送等功能，使得页面资源的传输速度得到了大幅提升。在 HTTP/1.1 时代，为了提升并行下载效率，浏览器为每个域名为了 6 个 TCP 连接；而采用 HTTP2 之后，浏览器只需要为每个域名维护一个 TCP 持久连接，同时还解决了 HTTP/1.1 队头阻塞的问题。")]),T._v(" "),_("p",[T._v("从目前的情况来看，HTTP2 似乎可以完美取代 HTTP1 了，不过 HTTP2 依然存在一些缺陷，于是就有了 HTTP3。")]),T._v(" "),_("h4",{attrs:{id:"tcp-的对头阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的对头阻塞"}},[T._v("#")]),T._v(" TCP 的对头阻塞")]),T._v(" "),_("p",[T._v("虽然 HTTP2 解决了应用层面的对头阻塞的问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设置及的。你可以把 TCP 连接堪称是两台计算机之间的一个虚拟管道，计算机的一段将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。")]),T._v(" "),_("p",[T._v("在 HTTP/1.1 协议栈中 TCP 是如何传输数据的。")]),T._v(" "),_("p",[T._v("从一端发送到另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。")]),T._v(" "),_("p",[T._v("不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接堪称是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据就需要等待该数据的重新传输。")]),T._v(" "),_("p",[T._v("所以我们把在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。")]),T._v(" "),_("p",[T._v("那队头阻塞是怎么影响 HTTP/2 传输的，首先我们来看正常情况下 HTTP/2 是怎么传输多路请求的。")]),T._v(" "),_("p",[T._v("通过该图，我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他 5 个连接依然可以继续传输数据。")]),T._v(" "),_("p",[T._v("所以随着丢包率的增加，HTTP2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2%的丢包率时，HTTP1.1 的传输效率反而比 HTTP/2 表现得更好。")]),T._v(" "),_("h4",{attrs:{id:"tcp-建立连接的延迟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-建立连接的延迟"}},[T._v("#")]),T._v(" TCP 建立连接的延迟")]),T._v(" "),_("p",[T._v("除了 TCP 队头阻塞之外，TCP 的握手过程也是影响传输效率的一个重要因素。")]),T._v(" "),_("p",[T._v("为了 TCP 协议建立连接的延时问题，我们还是先来回顾下网络延迟的概念，这会有助于你对后面内容的理解。网络延迟又称为 RTT（Round Trip Time）。我们把浏览器发送一个数据报到服务器，再从服务器返回数据报到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。")]),T._v(" "),_("p",[T._v("建立 TCP 连接时，需要花费多少个 RTT 呢？")]),T._v(" "),_("p",[T._v("我们知道 HTTP1 和 HTTP2 都是使用 TCP 协议来传输，而如果使用 HTPPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。")]),T._v(" "),_("ol",[_("li",[T._v("在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。")]),T._v(" "),_("li",[T._v("进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1~2 个 RTT。")])]),T._v(" "),_("p",[T._v('总之，在传输数据之前，我们需要花掉 3~4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内。也就是说总共要消耗掉 30~40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300~400 毫秒，这时用户就能明显地感受到"慢"了。')]),T._v(" "),_("h4",{attrs:{id:"tcp-协议僵化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议僵化"}},[T._v("#")]),T._v(" TCP 协议僵化")]),T._v(" "),_("p",[T._v("TCP 协议存在队头阻塞和建立连接延迟等缺点，如果通过改进 TCP 协议来解决这些问题是非常困难的。")]),T._v(" "),_("p",[T._v("第一个是中间设备的僵化。互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。")]),T._v(" "),_("p",[T._v("这些中间设备由很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。")]),T._v(" "),_("p",[T._v("所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。")]),T._v(" "),_("p",[T._v("除了中间设备僵化外，操作系统也是导致 TCP 协议僵化的另外一个原因。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此 要想自由地更新内核中的 TCP 协议也是非常困难的。")]),T._v(" "),_("h4",{attrs:{id:"quic-协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#quic-协议"}},[T._v("#")]),T._v(" QUIC 协议")]),T._v(" "),_("p",[T._v("HTTP/2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，我们几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。")]),T._v(" "),_("p",[T._v("因此，HTTP/3 选择一个折中地方法——UDP 协议，基于 UDP 实现了类似于 TCP 地多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。")]),T._v(" "),_("p",[T._v("HTTP/2 和 HTTP3 协议栈的比较=>TODO")]),T._v(" "),_("ul",[_("li",[T._v("实现了类似 TCP 的流量控制、可靠性传输的功能，虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。")]),T._v(" "),_("li",[T._v("集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。")]),T._v(" "),_("li",[T._v("实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据的单独传输，就解决了 TCP 中队头阻塞的问题。")]),T._v(" "),_("li",[T._v("实现了快速握手的功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据。这样可以大大提升首次打开页面的速度。")])]),T._v(" "),_("h4",{attrs:{id:"http3-的挑战"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http3-的挑战"}},[T._v("#")]),T._v(" HTTP3 的挑战")]),T._v(" "),_("p",[T._v("在技术层面上，HTTP3 是个完美的协议，但是应用到实际环境中面临着很多严峻挑战，主要来自于以下三个方面。")]),T._v(" "),_("p",[T._v("第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。")]),T._v(" "),_("p",[T._v("第二，部署 HTTP3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。")]),T._v(" "),_("p",[T._v("第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%~7%的丢包率。")]),T._v(" "),_("h4",{attrs:{id:"总结-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结-3"}},[T._v("#")]),T._v(" 总结")]),T._v(" "),_("p",[T._v("HTTP2 存在的问题，主要包括了 TCP 的队头阻塞、建立 TCP 连接的延时、TCP 协议僵化等问题。")]),T._v(" "),_("p",[T._v("这些问题都是 TCP 的内部问题，因此官方选择了创建新的 QUIC 协议。")]),T._v(" "),_("p",[T._v("HTTP3 正是基于 QUIC 协议的，你可以把 QUIC 看成是继承了 TCP+HTTP2 的多路复用+TLS 等功能的一套协议。从协议最底层对 Web 的文件传输作了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在 HTTP2 更加高效的网络。")]),T._v(" "),_("p",[T._v("虽说这套协议解决了 HTTP2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。")]),T._v(" "),_("p",[T._v("所以我认为：")]),T._v(" "),_("ol",[_("li",[T._v("从标准制定到实践再到协议优化还需要走很长的一段路；")]),T._v(" "),_("li",[T._v("因为动了底层协议，所以 HTTP3 的增长会比较缓慢，这和 HTTP2 有着本质的区别。")])])])}),[],!1,null,null,null);v.default=P.exports}}]);