(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{488:function(v,_,t){"use strict";t.r(_);var a=t(26),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"gc-垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc-垃圾回收机制"}},[v._v("#")]),v._v(" GC 垃圾回收机制")]),v._v(" "),t("p",[v._v("应用程序在运行过程中需要占用一定的内存空间,且在运行过后就必须将不再用到的内存释放掉,否则就会出现内存占用持续升高的情况,一方面会影响程序的运行速度,另一方面可能会导致整个程序的崩溃。")]),v._v(" "),t("h2",{attrs:{id:"javascript-中的内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中的内存管理"}},[v._v("#")]),v._v(" JavaScript 中的内存管理")]),v._v(" "),t("p",[t("strong",[v._v("内存管理")])]),v._v(" "),t("p",[v._v("内存：由可读写单元组成，表示一片可操作空间。")]),v._v(" "),t("p",[v._v("管理：人为地去操作一片空间的申请、使用、释放。")]),v._v(" "),t("p",[v._v("内存管理：开发者主动的去申请、使用、释放空间。")]),v._v(" "),t("p",[v._v("内存管理流程：分为申请、使用、释放三步。")]),v._v(" "),t("p",[t("strong",[v._v("JavaScript 中的内存管理")])]),v._v(" "),t("ul",[t("li",[v._v("JavaScript 语言中提供了垃圾回收机制(Garbage Collecation),简称 GC 机制。")]),v._v(" "),t("li",[v._v("javascript 中内存管理是自动的")])]),v._v(" "),t("h2",{attrs:{id:"全停顿-stop-the-world"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全停顿-stop-the-world"}},[v._v("#")]),v._v(" 全停顿(Stop The World)")]),v._v(" "),t("h2",{attrs:{id:"javascript-中的垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中的垃圾回收"}},[v._v("#")]),v._v(" JavaScript 中的垃圾回收")]),v._v(" "),t("p",[t("strong",[v._v("JS 中会被判定为垃圾的情形如下:")])]),v._v(" "),t("ul",[t("li",[v._v("对象不再被引用")]),v._v(" "),t("li",[v._v("对象不能从根上访问到")])]),v._v(" "),t("h2",{attrs:{id:"gc-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc-算法"}},[v._v("#")]),v._v(" GC 算法")]),v._v(" "),t("p",[v._v("GC 是一种机制，垃圾回收器完成具体的工作，工作的内容就是查找垃圾释放空间，回收空间如何分配等。算法就是工作时查找和回收所遵循的规则。所以 GC 算法就是垃圾回收器工作时所遵循的规则。")]),v._v(" "),t("p",[t("strong",[v._v("常见的 GC 算法:")])]),v._v(" "),t("ul",[t("li",[v._v("引用计数")]),v._v(" "),t("li",[v._v("标记清除")]),v._v(" "),t("li",[v._v("标记整理")]),v._v(" "),t("li",[v._v("分代回收")])]),v._v(" "),t("h3",{attrs:{id:"引用计数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[v._v("#")]),v._v(" 引用计数")]),v._v(" "),t("p",[t("strong",[v._v("实现原理：")]),v._v(" 设置引用数，判断当前引用数是否为 0")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("引用计数器")])]),v._v(" "),t("li",[t("p",[v._v("引用关系改变时修改引用数")])]),v._v(" "),t("li",[t("p",[v._v("引用数为 0 时立即回收")])])]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ul",[t("li",[v._v("可以及时回收垃圾对象")]),v._v(" "),t("li",[v._v("减少程序卡顿时间")])]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ul",[t("li",[v._v("无法回收循环引用的对象")]),v._v(" "),t("li",[v._v("资源消耗大")])]),v._v(" "),t("h3",{attrs:{id:"标记清除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[v._v("#")]),v._v(" 标记清除")]),v._v(" "),t("p",[t("strong",[v._v("实现原理："),t("strong",[v._v("分为")]),v._v("标记")]),v._v("和"),t("strong",[v._v("清除")]),v._v("两个阶段完成。")]),v._v(" "),t("ul",[t("li",[v._v("遍历所有对象找到活动对象进行标记。")]),v._v(" "),t("li",[v._v("遍历所有对象清除没有标记对象，同时也会抹掉标记，方便下一次工作。")]),v._v(" "),t("li",[v._v("回收垃圾相应的空间，放在空闲链表上")])]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ul",[t("li",[v._v("可以回收循环引用的对象")])]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ul",[t("li",[v._v("容易产生碎片化空间，不能让空间最大化利用")]),v._v(" "),t("li",[v._v("不会立即回收垃圾对象（清除时，程序是停止工作的）")])]),v._v(" "),t("h3",{attrs:{id:"标记整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记整理"}},[v._v("#")]),v._v(" 标记整理")]),v._v(" "),t("p",[t("strong",[v._v("实现原理：")]),v._v(" 可以看作是标记清除的增强版。")]),v._v(" "),t("ul",[t("li",[v._v("标记阶段的操作与标记清除一致")]),v._v(" "),t("li",[v._v("清除阶段会先执行整理，移动对象位置，然后再进行整体的回收。")])]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ul",[t("li",[v._v("较少碎片化空间")])]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ul",[t("li",[v._v("不会立即回收垃圾对象")])]),v._v(" "),t("h2",{attrs:{id:"v8-引擎垃圾回收策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-引擎垃圾回收策略"}},[v._v("#")]),v._v(" V8 引擎垃圾回收策略")]),v._v(" "),t("ul",[t("li",[v._v("采用分代回收的思想")]),v._v(" "),t("li",[v._v("内存分为新生代和老生代")])]),v._v(" "),t("p",[v._v("针对不同代采用最高效的 GC 算法对不同对象进行回收：")]),v._v(" "),t("ol",[t("li",[v._v("新生代:对象的存活时间较短.新生代对象或只经过一次垃圾回收的对象。（局部变量等）")]),v._v(" "),t("li",[v._v("老生代:对象的存活时间较长.经历过一次或多次垃圾回收的对象。（闭包，全局变量等）")])]),v._v(" "),t("p",[v._v("V8 堆的空间等于新生代空间加上老生代空间.且针对不同的操作系统对空间做了内存的限制。")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("类型\\系统位数")]),v._v(" "),t("th",[v._v("64 位")]),v._v(" "),t("th",[v._v("32 位")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("新生代")]),v._v(" "),t("td",[v._v("32MB")]),v._v(" "),t("td",[v._v("16MB")])]),v._v(" "),t("tr",[t("td",[v._v("老生代")]),v._v(" "),t("td",[v._v("1400MB")]),v._v(" "),t("td",[v._v("700MB")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("限制内存的原因:")]),v._v(" "),t("p",[v._v("对于浏览器来说,这样的内存是足够使用的。")]),v._v(" "),t("p",[v._v("基于 GC 机制,经过不断的测试,如果内存在设置大一点,GC 回收使用增量标记只需 50ms，但是非增量标记需要 1s，会造成用户感知上的卡顿。")])]),v._v(" "),t("p",[t("strong",[v._v("V8 常见 GC 算法：")])]),v._v(" "),t("ul",[t("li",[v._v("分代回收")]),v._v(" "),t("li",[v._v("空间复制")]),v._v(" "),t("li",[v._v("标记清除")]),v._v(" "),t("li",[v._v("标记整理")]),v._v(" "),t("li",[v._v("标记增量")])]),v._v(" "),t("h3",{attrs:{id:"回收新生代对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回收新生代对象"}},[v._v("#")]),v._v(" 回收新生代对象")]),v._v(" "),t("p",[v._v("主要采用复制算法(Scavenge 算法)加标记整理算法.而 Scavenge 算法的具体实现,主要采用了 Cheney 算法。Cheney 算法将新生代内存分为两个等大空间,使用空间为 From,空闲空间为 To。")]),v._v(" "),t("p",[v._v("检查 From 空间内的存活对象,若对象存活,检查对象是否符合晋升条件,若符合条件则晋升到老生代,否则将对象从 From 空间复制到 To 空间。完成复制后,将 From 空间与 To 空间进行角色翻转完成释放")]),v._v(" "),t("blockquote",[t("p",[v._v("拷贝过程中可能出现晋升；晋升就是将新生代对象移动至老生代")])]),v._v(" "),t("p",[t("strong",[v._v("对象晋升机制")])]),v._v(" "),t("ul",[t("li",[v._v("一轮 GC 还存活的新生代需要晋升")]),v._v(" "),t("li",[v._v("当对象从 From 空间复制到 To 空间时,若 To 空间使用超过 25%,则对象直接晋升到老生代中")])]),v._v(" "),t("blockquote",[t("p",[v._v("设置为 25%的比例的原因是,当完成 Scavenge 回收后,To 空间将翻转成 From 空间,继续进行对象内存的分配.若占比过大,将影响后续内存分配")])]),v._v(" "),t("h3",{attrs:{id:"回收老生代对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回收老生代对象"}},[v._v("#")]),v._v(" 回收老生代对象")]),v._v(" "),t("p",[v._v("主要采用标记清除、标记整理、增量标记算法（主要使用标记清除算法,只有在内存分配不足时,采用标记整理算法）")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("首先使用标记清除完成垃圾空间的回收;")])]),v._v(" "),t("li",[t("p",[v._v("采用标记整理进行空间优化;")])]),v._v(" "),t("li",[t("p",[v._v("采用增量标记进行效率优化;")])])]),v._v(" "),t("blockquote",[t("p",[v._v("垃圾回收工作时会阻塞 JS 执行。")]),v._v(" "),t("p",[v._v("标量增记：程序执行与标记交替进行来完成标记清除，从而提高效率")])]),v._v(" "),t("h3",{attrs:{id:"新生代和老生代回收对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代和老生代回收对比"}},[v._v("#")]),v._v(" 新生代和老生代回收对比")]),v._v(" "),t("p",[v._v("新生代由于占用空间比较少,采用空间换时间机制。")]),v._v(" "),t("p",[v._v("老生代区域空间较大,不太适合大量的复制算法和标记整理,所以最常用的是标记清除算法,为了就是让全停顿的时间尽量减少。")]),v._v(" "),t("h2",{attrs:{id:"内存问题的体现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存问题的体现"}},[v._v("#")]),v._v(" 内存问题的体现")]),v._v(" "),t("ul",[t("li",[v._v("页面出现延迟加载或经常性暂停")]),v._v(" "),t("li",[v._v("页面持续性出现糟糕的性能")]),v._v(" "),t("li",[v._v("页面的性能随时间延长越来越差")])]),v._v(" "),t("h2",{attrs:{id:"监控内存的几种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#监控内存的几种方式"}},[v._v("#")]),v._v(" 监控内存的几种方式")]),v._v(" "),t("p",[t("strong",[v._v("界定内存问题的标准：")])]),v._v(" "),t("ul",[t("li",[v._v("内存泄漏：内存使用持续升高")]),v._v(" "),t("li",[v._v("内存膨胀：在多数设备上都存在性能内存问题")]),v._v(" "),t("li",[v._v("频繁垃圾回收：通过内存变化图进行分析")])]),v._v(" "),t("p",[t("strong",[v._v("内存监控的几种方式：")])]),v._v(" "),t("ul",[t("li",[v._v("浏览器任务管理器")]),v._v(" "),t("li",[v._v("Timeline 时序图记录")]),v._v(" "),t("li",[v._v("堆快照查找分离 DOM")]),v._v(" "),t("li",[v._v("判断是否存在频繁 GC")])]),v._v(" "),t("h2",{attrs:{id:"代码优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码优化"}},[v._v("#")]),v._v(" 代码优化")]),v._v(" "),t("ul",[t("li",[v._v("避免全局变量")]),v._v(" "),t("li",[v._v("避免全局查找")]),v._v(" "),t("li",[v._v("避免循环引用")]),v._v(" "),t("li",[v._v("采用字面量替换 New 操作")]),v._v(" "),t("li",[v._v("使用 setTimeout 替换 setInterval")]),v._v(" "),t("li",[v._v("采用事件委托")]),v._v(" "),t("li",[v._v("合并循环变量和条件")]),v._v(" "),t("li",[v._v("数组循环优化")]),v._v(" "),t("li",[v._v("使用文档碎片替代多次 append")]),v._v(" "),t("li",[v._v("使用 clone 替代 create")]),v._v(" "),t("li",[v._v("innerHTML 创建 DOM")])]),v._v(" "),t("h2",{attrs:{id:"性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[v._v("#")]),v._v(" 性能优化")]),v._v(" "),t("ul",[t("li",[v._v("堆栈中的 JS 执行过程")]),v._v(" "),t("li",[v._v("减少判断层级")]),v._v(" "),t("li",[v._v("减少作用域链查找层级")]),v._v(" "),t("li",[v._v("减少数据读取次数")]),v._v(" "),t("li",[v._v("字面量与构造式")]),v._v(" "),t("li",[v._v("减少循环体中活动")]),v._v(" "),t("li",[v._v("减少声明及语句数")]),v._v(" "),t("li",[v._v("惰性函数与性能")]),v._v(" "),t("li",[v._v("采用事件绑定")])]),v._v(" "),t("h2",{attrs:{id:"在线测试-js-代码效率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在线测试-js-代码效率"}},[v._v("#")]),v._v(" 在线测试 JS 代码效率")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://jsbench.me/",target:"_blank",rel:"noopener noreferrer"}},[v._v("JSBench"),t("OutboundLink")],1)]),v._v(" "),t("h2",{attrs:{id:"哪些操作会造成内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哪些操作会造成内存泄漏"}},[v._v("#")]),v._v(" 哪些操作会造成内存泄漏？")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("1.意外的全局变量")])]),v._v(" "),t("li",[t("p",[v._v("2.被遗忘的计时器或回调函数")])]),v._v(" "),t("li",[t("p",[v._v("3.脱离 DOM 的引用")])]),v._v(" "),t("li",[t("p",[v._v("4.闭包")])]),v._v(" "),t("li",[t("p",[v._v("第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。")])]),v._v(" "),t("li",[t("p",[v._v("第二种情况是我们设置了"),t("code",[v._v("setInterval")]),v._v("定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。")])]),v._v(" "),t("li",[t("p",[v._v("第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。")])]),v._v(" "),t("li",[t("p",[v._v("第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);