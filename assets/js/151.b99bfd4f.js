(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{532:function(a,t,s){"use strict";s.r(t);var v=s(26),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"虚拟-dom-与-diff-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-与-diff-算法"}},[a._v("#")]),a._v(" 虚拟 DOM 与 diff 算法")]),a._v(" "),s("h2",{attrs:{id:"了解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#了解"}},[a._v("#")]),a._v(" 了解")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("先简单的介绍虚拟DOM和diff算法\n\n房子三室一厅一厨一卫一个花园一个阳台\n\n改变，起居室多了一个小沙发，床本来从东边摆的，现在靠西边挪了挪，电视没了，阳台的墙向南边移了移，\n\n怎么完成这次装修\n\n\n\n最笨的方法：全拆，重建，效率太低，代价昂贵。\n\n但不是最小量的更新，所以我们需要diff，different\n\n精细化比对最小量更新，计算机领域叫最小量更新，代价小也不昂贵，性能优化，效率提升\n")])])]),s("h2",{attrs:{id:"虚拟-dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[a._v("#")]),a._v(" 虚拟 DOM")]),a._v(" "),s("p",[s("strong",[a._v("虚拟 DOM：用 JavaScript 对象描述 DOM 的层次结构。DOM 中的一切属性都在虚拟 DOM 中有对应的属性。")])]),a._v(" "),s("h2",{attrs:{id:"diff-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[a._v("#")]),a._v(" diff 算法")]),a._v(" "),s("p",[s("strong",[a._v("diff 算法可以进行精细化比对，实现最小量更新。")])]),a._v(" "),s("p",[a._v("diff 算法是实现最小量更新的，不会跨层对比")]),a._v(" "),s("p",[s("strong",[a._v("diff 是发生在虚拟 DOM 上的")])]),a._v(" "),s("p",[s("strong",[a._v("新虚拟 DOM 和老虚拟 DOM 进行 diff（精细化比较），算出应该如何最小量更新，最后反映到真正的 DOM 上")])]),a._v(" "),s("p",[s("strong",[a._v("（新的虚拟 DOM 和老的虚拟 DOM 进行对比）")])]),a._v(" "),s("p",[a._v("真实 DOM 结构处理比较复杂，把 DOM 编程一个 JS 对象，sel，data，children")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 视频目录\nsnabbdom简介（虚拟DOM鼻祖）\n\nsnabbdom的h函数如何工作\n\ndiff算法原理\n\n手写diff算法\n\n\n\n介绍宏观背景、历史沿革\n\n先学会怎么用\n\n在研究底层原理\n\n最后手写它，彻底掌握它\n")])])]),s("h2",{attrs:{id:"snabbdom-简介和测试搭建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#snabbdom-简介和测试搭建"}},[a._v("#")]),a._v(" snabbdom 简介和测试搭建")]),a._v(" "),s("p",[a._v("snabbdom 是瑞典语单词，单词原意“速度”")]),a._v(" "),s("p",[a._v("snabbdom 是著名的虚拟 DOM 库，是 diff 算法的鼻祖，Vue 源码借鉴了 snabbdom.")]),a._v(" "),s("p",[a._v("核心代码 200 行")]),a._v(" "),s("p",[a._v("使用 js 版的 snabbdom 库，从 npm 下载，npm i -D snabbdom")]),a._v(" "),s("p",[a._v("snabbdom 库是 DOM 库，所以不能再 nodejs 环境运行，所以我们需要搭建 webpack 和 webpak-dev-server 开发环境，不需要安装任何 loader")]),a._v(" "),s("p",[a._v("必须安装最新的 webpack@5,这是因为 webpack4 不能读取 package.json 中 exports 的能力。")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[a._v("npm i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("D")]),a._v(" webpack@"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" webpack"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("cli@"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" webpack"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server@"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("\n")])])]),s("p",[a._v("webpack.config.js 文件")]),a._v(" "),s("p",[a._v("跑通 snabbdom 官方 DEMO")]),a._v(" "),s("p",[a._v("1.虚拟 DOM 如何被渲染函数（h 函数）产生？")]),a._v(" "),s("p",[a._v("手写 h 函数")]),a._v(" "),s("p",[a._v("2.diff 算法原理")]),a._v(" "),s("p",[a._v("手写 diff 算法")]),a._v(" "),s("p",[a._v("3.虚拟 DOM 如何通过 diff 变成真正的 DOM 的")]),a._v(" "),s("p",[a._v("事实上，虚拟 DOM 变回真正的 DOM，是涵盖在 diff 算法里面的")]),a._v(" "),s("h2",{attrs:{id:"h-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#h-函数"}},[a._v("#")]),a._v(" h 函数")]),a._v(" "),s("p",[a._v("h 函数用来产生虚拟节点")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("h 函数用来产生虚拟节点（vnode）")]),a._v(" "),s("p",[a._v("h 有三个参数，第一个标签名字，第二个是对象")])]),a._v(" "),s("li",[s("p",[a._v("h 函数嵌套使用，从而得到虚拟 DOM 树")])]),a._v(" "),s("li",[s("p",[a._v("子元素只有一个可以省略数组")])]),a._v(" "),s("li",[s("p",[a._v("h 函数用法很活")])])]),a._v(" "),s("p",[a._v("虚拟节点有哪些属性")]),a._v(" "),s("p",[a._v("children：子元素，undefined，没有子元素")]),a._v(" "),s("p",[a._v("data：属性，样式")]),a._v(" "),s("p",[a._v("elm：对应的真正 DOM 节点，undefined 代表还没有上树")]),a._v(" "),s("p",[a._v("key：节点唯一标识，服务于更新")]),a._v(" "),s("p",[a._v("sel：选择器")]),a._v(" "),s("p",[a._v("text")]),a._v(" "),s("h3",{attrs:{id:"手写-h-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手写-h-函数"}},[a._v("#")]),a._v(" 手写 h 函数")]),a._v(" "),s("p",[a._v("定义 vnode")]),a._v(" "),s("p",[a._v("写 h 函数，函数的重载")]),a._v(" "),s("h2",{attrs:{id:"diff-算法-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法-2"}},[a._v("#")]),a._v(" diff 算法")]),a._v(" "),s("h3",{attrs:{id:"感受-diff-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#感受-diff-算法"}},[a._v("#")]),a._v(" 感受 diff 算法")]),a._v(" "),s("ul",[s("li",[s("p",[s("strong",[a._v("最小量更新可以使用丑八怪实验法，真的是最小量更新")]),a._v("，当然 key 很重要，key 是这个节点的唯一标识，告诉 diff 算法，在更改前后它们是同一个 DOM 节点。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("只有是同一个虚拟节点，才进行精细化比较")]),a._v("，否则就是暴力删除旧的、插入新的；")])])]),a._v(" "),s("blockquote",[s("p",[a._v("问题：如何定义是同一个虚拟节点")]),a._v(" "),s("p",[a._v("答：选择器相同且 key 相同。")]),a._v(" "),s("p",[a._v("(父节点不能变)")])]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("只进行同层比较，不会进行跨层比较")]),a._v("。即使是同一个虚拟节点，但是跨层了，对不起，精细化比较不 diff 你，而是暴力删除旧的、然后插入新的。")])]),a._v(" "),s("h3",{attrs:{id:"diff-处理新旧节点不是同一个节点时"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#diff-处理新旧节点不是同一个节点时"}},[a._v("#")]),a._v(" diff 处理新旧节点不是同一个节点时")]),a._v(" "),s("ol",[s("li",[a._v("oldVnode 是虚拟节点吗？不是的话需要变为虚拟节点")])]),a._v(" "),s("ul",[s("li",[a._v("DOM 节点：需要变为虚拟节点")])]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[a._v("判断 oldVnode 和 newVnode 是不是同一个虚拟节点，不是的话，删除旧的，插入新的（创建节点时，所有子节点是需要递归出来的，需要递归）")]),a._v(" "),s("blockquote",[s("p",[a._v("如何定义是一个节点")])])])]),a._v(" "),s("h3",{attrs:{id:"diff-处理新旧节点是同一个节点时"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#diff-处理新旧节点是同一个节点时"}},[a._v("#")]),a._v(" diff 处理新旧节点是同一个节点时")]),a._v(" "),s("p",[a._v("进行精细化比较")]),a._v(" "),s("h3",{attrs:{id:"第一次上树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第一次上树"}},[a._v("#")]),a._v(" 第一次上树")]),a._v(" "),s("h3",{attrs:{id:"手写递归创建子节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手写递归创建子节点"}},[a._v("#")]),a._v(" 手写递归创建子节点")]),a._v(" "),s("h2",{attrs:{id:"patch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#patch"}},[a._v("#")]),a._v(" Patch")]),a._v(" "),s("p",[a._v("创建 patch 函数 patch（el 元素，虚拟节点），让虚拟节点上树，")]),a._v(" "),s("h2",{attrs:{id:"疑问"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#疑问"}},[a._v("#")]),a._v(" 疑问")]),a._v(" "),s("p",[a._v("DOM 如何变为虚拟 DOM（属于模板编译原理范畴）=》不涉及")])])}),[],!1,null,null,null);t.default=_.exports}}]);