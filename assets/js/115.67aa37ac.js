(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{498:function(n,t,r){"use strict";r.r(t);var e=r(26),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"bind"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[n._v("#")]),n._v(" Bind")]),n._v(" "),r("p",[r("strong",[n._v("bind 函数的实现步骤：")])]),n._v(" "),r("ul",[r("li",[n._v("1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。")]),n._v(" "),r("li",[n._v("2.保存当前函数的引用，获取其余传入参数值。")]),n._v(" "),r("li",[n._v("3.创建一个函数返回")]),n._v(" "),r("li",[n._v("4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('// bind 函数实现\nFunction.prototype.myBind = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== "function") {\n    throw new TypeError("Error");\n  }\n\n  // 获取参数\n  var args = [...arguments].slice(1),\n    fn = this;\n\n  return function Fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    );\n  };\n};\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);