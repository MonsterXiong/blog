# GC 垃圾回收机制

应用程序在运行过程中需要占用一定的内存空间,且在运行过后就必须将不再用到的内存释放掉,否则就会出现内存占用持续升高的情况,一方面会影响程序的运行速度,另一方面可能会导致整个程序的崩溃。

## JavaScript 中的内存管理

JavaScript 语言中提供了垃圾回收机制(Garbage Collecation),简称 GC 机制。

## 全停顿(Stop The World)

## JavaScript 中的垃圾回收

JS 中会被判定为垃圾的情形如下:

- 对象不再被引用
- 对象不能从根上访问到

## GC 算法

常见的 GC 算法:

- 引用计数
- 标记清除
- 标记整理
- 分代回收

## V8 引擎垃圾回收策略

- 采用分代回收的思想
- 内存分为新生代和老生代

针对不同对象采用不同算法:

1. 新生代:对象的存活时间较短.新生代对象或只经过一次垃圾回收的对象。
2. 老生代:对象的存活时间较长.经历过一次或多次垃圾回收的对象。

V8 堆的空间等于新生代空间加上老生代空间.且针对不同的操作系统对空间做了内存的限制。

| 类型\系统位数 | 64 位  | 32 位 |
| ------------- | ------ | ----- |
| 新生代        | 1400MB | 700MB |
| 老生代        | 32MB   | 700MB |

限制内存的原因:
针对浏览器来说,这样的内存是足够使用的。
针对浏览器的 GC 机制,经过不断的测试,如果内存在设置大一点,GC 回收的时间就会达到用户的感知,会造成感知上的卡顿。

### 回收新生代对象

回收新生代对象主要采用复制算法(Scavenge 算法)加标记整理算法.而 Scavenge 算法的具体实现,主要采用了 Cheney 算法。

Cheney 算法将内存分为两个等大空间,使用空间为 From,空闲空间为 To。

检查 From 空间内的存活对象,若对象存活,检查对象是否符合晋升条件,若符合条件则晋升到老生代,否则将对象从 From 空间复制到 To 空间。若对象不存活,则释放不存活对象的空间。完成复制后,将 From 空间与 To 空间进行角色翻转。

### 对象晋升机制

一轮 GC 还存活的新生代需要晋升。
当对象从 From 空间复制到 To 空间时,若 To 空间使用超过 25%,则对象直接晋升到老生代中.设置为 25%的比例的原因是,当完成 Scavenge 回收后,To 空间将翻转成 From 空间,继续进行对象内存的分配.若占比过大,将影响后续内存分配。

### 回收老生代对象

回收老生代对象主要采用标记清除、标记整理、增量标记算法,主要使用标记清除算法,只有在内存分配不足时,采用标记整理算法。

1. 首先使用标记清除完成垃圾空间的回收;
2. 采用标记整理进行空间优化;
3. 采用增量标记进行效率优化;

### 新生代和老生代回收对比

新生代由于占用空间比较少,采用空间换时间机制。
老生代区域空间较大,不太适合大量的复制算法和标记整理,所以最常用的是标记清除算法,为了就是让全停顿的时间尽量减少。

## 哪些操作会造成内存泄漏？

- 1.意外的全局变量
- 2.被遗忘的计时器或回调函数
- 3.脱离 DOM 的引用
- 4.闭包

- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- 第二种情况是我们设置了`setInterval`定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- 第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

## 内存泄露识别方法

- 先写一段比较消耗内存的代码
- 使用浏览器的 performance 来监控内存的变化

## 性能优化

1. 避免使用全局变量
   - 全局变量会挂在在 window 下;
   - 全局变量至少有一个引用计数;
   - 全局变量存活更久,持续占用内存;
   - 在明确数据作用域的情况下,尽量使用局部变量;
2. 减少层级判断
3. 减少数据读取次数(对于频繁使用的数据,我们要对数据进行缓存)
4. 减少循环体中的活动
5. 事件绑定优化(可以使用事件委托)
6. 避开闭包陷阱
