# GC 垃圾回收机制

应用程序在运行过程中需要占用一定的内存空间,且在运行过后就必须将不再用到的内存释放掉,否则就会出现内存占用持续升高的情况,一方面会影响程序的运行速度,另一方面可能会导致整个程序的崩溃。

## JavaScript 中的内存管理

**内存管理**

内存：由可读写单元组成，表示一片可操作空间。

管理：人为地去操作一片空间的申请、使用、释放。

内存管理：开发者主动的去申请、使用、释放空间。

内存管理流程：分为申请、使用、释放三步。

**JavaScript 中的内存管理**

- JavaScript 语言中提供了垃圾回收机制(Garbage Collecation),简称 GC 机制。
- javascript 中内存管理是自动的

## 全停顿(Stop The World)

## JavaScript 中的垃圾回收

**JS 中会被判定为垃圾的情形如下:**

- 对象不再被引用
- 对象不能从根上访问到

## GC 算法

GC 是一种机制，垃圾回收器完成具体的工作，工作的内容就是查找垃圾释放空间，回收空间如何分配等。算法就是工作时查找和回收所遵循的规则。所以 GC 算法就是垃圾回收器工作时所遵循的规则。

**常见的 GC 算法:**

- 引用计数
- 标记清除
- 标记整理
- 分代回收

### 引用计数

**实现原理：** 设置引用数，判断当前引用数是否为 0

- 引用计数器

- 引用关系改变时修改引用数
- 引用数为 0 时立即回收

**优点：**

- 可以及时回收垃圾对象
- 减少程序卡顿时间

**缺点：**

- 无法回收循环引用的对象
- 资源消耗大

### 标记清除

**实现原理：**分为**标记**和**清除**两个阶段完成。

- 遍历所有对象找到活动对象进行标记。
- 遍历所有对象清除没有标记对象，同时也会抹掉标记，方便下一次工作。
- 回收垃圾相应的空间，放在空闲链表上

**优点：**

- 可以回收循环引用的对象

**缺点：**

- 容易产生碎片化空间，不能让空间最大化利用
- 不会立即回收垃圾对象（清除时，程序是停止工作的）

### 标记整理

**实现原理：** 可以看作是标记清除的增强版。

- 标记阶段的操作与标记清除一致
- 清除阶段会先执行整理，移动对象位置，然后再进行整体的回收。

**优点：**

- 较少碎片化空间

**缺点：**

- 不会立即回收垃圾对象

## V8 引擎垃圾回收策略

- 采用分代回收的思想
- 内存分为新生代和老生代

针对不同代采用最高效的 GC 算法对不同对象进行回收：

1. 新生代:对象的存活时间较短.新生代对象或只经过一次垃圾回收的对象。（局部变量等）
2. 老生代:对象的存活时间较长.经历过一次或多次垃圾回收的对象。（闭包，全局变量等）

V8 堆的空间等于新生代空间加上老生代空间.且针对不同的操作系统对空间做了内存的限制。

| 类型\系统位数 | 64 位  | 32 位 |
| ------------- | ------ | ----- |
| 新生代        | 32MB   | 16MB  |
| 老生代        | 1400MB | 700MB |

> 限制内存的原因:
>
> 对于浏览器来说,这样的内存是足够使用的。
>
> 基于 GC 机制,经过不断的测试,如果内存在设置大一点,GC 回收使用增量标记只需 50ms，但是非增量标记需要 1s，会造成用户感知上的卡顿。

**V8 常见 GC 算法：**

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

### 回收新生代对象

主要采用复制算法(Scavenge 算法)加标记整理算法.而 Scavenge 算法的具体实现,主要采用了 Cheney 算法。Cheney 算法将新生代内存分为两个等大空间,使用空间为 From,空闲空间为 To。

检查 From 空间内的存活对象,若对象存活,检查对象是否符合晋升条件,若符合条件则晋升到老生代,否则将对象从 From 空间复制到 To 空间。完成复制后,将 From 空间与 To 空间进行角色翻转完成释放

> 拷贝过程中可能出现晋升；晋升就是将新生代对象移动至老生代

**对象晋升机制**

- 一轮 GC 还存活的新生代需要晋升
- 当对象从 From 空间复制到 To 空间时,若 To 空间使用超过 25%,则对象直接晋升到老生代中

> 设置为 25%的比例的原因是,当完成 Scavenge 回收后,To 空间将翻转成 From 空间,继续进行对象内存的分配.若占比过大,将影响后续内存分配

### 回收老生代对象

主要采用标记清除、标记整理、增量标记算法（主要使用标记清除算法,只有在内存分配不足时,采用标记整理算法）

- 首先使用标记清除完成垃圾空间的回收;

- 采用标记整理进行空间优化;

- 采用增量标记进行效率优化;

> 垃圾回收工作时会阻塞 JS 执行。
>
> 标量增记：程序执行与标记交替进行来完成标记清除，从而提高效率

### 新生代和老生代回收对比

新生代由于占用空间比较少,采用空间换时间机制。

老生代区域空间较大,不太适合大量的复制算法和标记整理,所以最常用的是标记清除算法,为了就是让全停顿的时间尽量减少。

## 内存问题的体现

- 页面出现延迟加载或经常性暂停
- 页面持续性出现糟糕的性能
- 页面的性能随时间延长越来越差

## 监控内存的几种方式

**界定内存问题的标准：**

- 内存泄漏：内存使用持续升高
- 内存膨胀：在多数设备上都存在性能内存问题
- 频繁垃圾回收：通过内存变化图进行分析

**内存监控的几种方式：**

- 浏览器任务管理器
- Timeline 时序图记录
- 堆快照查找分离 DOM
- 判断是否存在频繁 GC

## 代码优化

- 避免全局变量
- 避免全局查找
- 避免循环引用
- 采用字面量替换 New 操作
- 使用 setTimeout 替换 setInterval
- 采用事件委托
- 合并循环变量和条件
- 数组循环优化
- 使用文档碎片替代多次 append
- 使用 clone 替代 create
- innerHTML 创建 DOM

## 性能优化

- 堆栈中的 JS 执行过程
- 减少判断层级
- 减少作用域链查找层级
- 减少数据读取次数
- 字面量与构造式
- 减少循环体中活动
- 减少声明及语句数
- 惰性函数与性能
- 采用事件绑定

## 在线测试 JS 代码效率

[JSBench](https://jsbench.me/)

## 哪些操作会造成内存泄漏？

- 1.意外的全局变量
- 2.被遗忘的计时器或回调函数
- 3.脱离 DOM 的引用
- 4.闭包

- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- 第二种情况是我们设置了`setInterval`定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- 第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。
