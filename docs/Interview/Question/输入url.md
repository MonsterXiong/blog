---
sidebar: auto
---

# 从输入 URL 到页面加载的过程

## 从浏览器接受 url 到开启网络请求线程

- 多进程的浏览器
- 多线程的浏览器内核
- 解析 URL
- 网络请求都是单独的线程
- 更多

**浏览器的进程/线程模型，JS 的运行机制**

### 多进程的浏览器

浏览器是多进程的，有一个主控进程，以及每一个 tab 页面都会新开一个进程（某些情况下多个 tab 会合并进程）

进程可能包含主控进程，插件进程，GPU，tab 页（浏览器内核）等等

- Browser 进程：浏览器的主进程（负责协调、主控），只有一个
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时创建
- GPU 进程：最多一个，用于 3D 绘制
- 浏览器渲染进程（内核）：默认每个 Tab 页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 tab 会合成一个进程）

### 多线程的浏览器内核

每一个 tab 页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几类子线程

- GUI 渲染线程
- JS 引擎线程
- 事件触发线程
- 定时触发器线程
- 异步 http 请求线程（网络请求线程）

可以看到，JS 引擎是内核进程的一个线程，所以 JS 引擎是单线程的

### 解析 URL

输入 URL 后，会进行解析（URL 的本质就是统一资源定位符）

URL 一般包含几大部分：

- protocol,协议头，譬如有 http，ftp 等
- host，主机域名或 IP 地址
- port，端口号
- path,目录路径
- query，查询参数
- fragment：#后的 hash 值，一般用来定位到某个位置

### 网络请求都是单独的线程

每次网络请求时都需要开辟单独的线程进行，譬如如果 URL 解析到 http 协议，就会新建一个网络线程去处理资源下载

因此浏览器会根据协议出的协议，开辟一个网络线程，前往请求资源

### 更多

[从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)

## 开启网络请求线程到发出一个完整的 http 请求

- DNS 查询得到 IP
- tcp/ip 请求
- 五层因特网协议栈

### DNS 查询得到 IP

如果输入的是域名，需要进行 DNS 解析成 IP，大致流程：

- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，没有的话就用 host
- 如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP

注意，域名查询是有可能是经过了 CDN 调度器的（如果有 cdn 存储功能的话）
而且，需要知道 dns 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 dns-prefetch 优化

### tcp/ip 请求

http 的本质就是 tcp/ip 请求

需要了解 3 次握手建立连接以及断开连接时的四次挥手

tcp 将 http 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输

三次握手的步骤：（抽象派）

```
客户端：hello，你是server吗？
服务端：hello,我是server，你是client吗？
客户端：yes，我是client
```

建立连接成功后，接下来就正式传输数据

然后，待到断开连接时，需要进行四次挥手（因为时全双工的，所以需要四次挥手）

四次挥手的步骤：（抽象派）

```
主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
被动方：收到通道关闭的信息
被动方：那我也告诉你，我这边向你的主动通道也关闭了
主动方：最后收到数据，之后双方无法通信
```

### tcp/ip 的并发限制

浏览器对同一域名下并发的 tcp 连接是有限制的（2-10 个不等）

而且在 http1.0 中往往一个资源下载就需要对应一个 tcp/ip 请求

针对这个瓶颈，又出下了很多资源优化方案

### get 和 post 的区别

get 和 post 虽然本质都是 tcp/ip，但两者除了在 http 层面外，在 tcp/ip 层面也有区别。
get 会产生一个 tcp 数据包，post 两个

具体就是：

- get 请求时，浏览器会把 headers 和 data 一起发送出去，服务器响应 200（返回数据）
- post 请求时，浏览器先发送 headers，服务器响应 100 continue，浏览器再发送 data，服务器响应 200（返回数据）

这里的区别时 specification（规范）层面，而不是 implementation（对规范的实现）

### 五层因特网协议栈

从客户端发出 http 请求到服务器接收，中间会经过一系列的流程

从应用层的发送 http 请求，到传输层建立三次握手建立 tcp/ip 连接，再到网络层的 ip 寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输

服务端的接收就是反过来的步骤

五层因特网协议栈其实就是：

```
1. 应用层（dns，http）DNS解析成IP并发送http请求
2. 传输层（tcp,udp）建立tcp连接（三次握手）
3. 网络层（IP，ARP）IP寻址
4. 数据链路层（PPP）封装成帧
5. 物理层（利用物理介质传输比特流）物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

```

还有一个完成的 OSI 七层框架，与之相比，多了会话层、表示层。

OSI 七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

```
表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等

会话层：它具体管理不同用户和进程之间的对话，如控制登录和注销过程。
```

## 从服务器接收到请求到对应后台接收到请求

- 负载均衡
- 后台的处理

服务端在接收到请求时，内部会进行很多的处理

### 负载均衡

对于大型项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡

简单地说：
用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户

### 后台的处理

一般后台都是部署到容器中的，所以一般为：

- 先是容器接收到请求（如 tomcat 容器）
- 然后对应容器中的后台程序接收到请求（如 java 程序）
- 然后就是后台会有自己的统一处理，处理完后响应结果

概括下：

- 一般有的后端是有统一的验证的，如安全拦截，跨域验证
- 如果这一步不符合规则，就会直接返回相应的 http 报文（如拒绝请求等）
- 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
- 等程序执行完毕后，就会返回一个 http 响应包（一般这一步也会经过多层封装）
- 然后就是将这个包从后端发送到前端，完成交互

## 后台和前台的 http 交互

- http 报文结构
- cookie 以及优化
- gzip 压缩
- 长连接与短连接
- http2.0
- https

前后端交互时，http 报文作为信息的载体

### http 报文结构

报文一般包括了：通用头部，请求/响应头部，请求/响应体

---- 待更新

### cookie 以及优化

---- 待更新

### gzip 压缩

---- 待更新

### 长连接与短连接

---- 待更新

### http2.0

---- 待更新

### https

---- 待更新

## 缓存问题-http 的缓存

- 强缓存与弱缓存
- 缓存头部简述
- 头部的区别

## 解析页面流程

- 流程简述
- HTML 解析，构建 DOM
- 生成 CSS 规则
- 构建渲染树
- 渲染
- 简单层与复合层
- Chrome 中的调试
- 资源外链的下载
- loader 和 domcontentloaded

### 流程简述

浏览器内核拿到内容后，渲染步骤大致可以分为一下几步：

```
1. 解析HTML树，构建DOM树
2. 解析CSS，生成CSS规则树
3. 合并DOM树和CSS规则，生成render树
4. 布局render树（Layout/reflow），负责个元素尺寸、位置的计算
5. 绘制render树（paint）,绘制页面像素信息
6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

```

HTML 解析，构建 DOM 树
整个渲染步骤中，HTML 解析是第一步

解析 HTML 到构建出 DOM 过程可以简述如下：

```
Bytes => characters => tokens => nodes => DOM
```

譬如假设有这样一个 HTML 页面：

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
```

浏览器的处理如下：
![解析HTML](https://pic4.zhimg.com/80/v2-83fcb412ec495490e5cde63dbee3bda3_720w.jpg)

列举其中的一些重点过程：

```
1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符
2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集
3. Lexing词法分析：分析的结果是得到一堆token，此时把他们转换成对象，这些对象分别定义他们的属性和规则
4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
例如：body对象的父节点就是HTML对象，然后段落P对象的父节点就是body对象
```

### 生成 CSS 规则

CSS 规则树的生成也是类似，简述为：

```
Bytes => characters => tokens => nodes => CSSOM
```

譬如 style.css 内容如下：

```css
body {
  font-size: 16px;
}
p {
  font-weight: bold;
}
span {
  color: red;
}
p span {
  display: none;
}
img {
  float: right;
}
```

最终的 CSSOM 树就是：
![CSSOM树](https://pic1.zhimg.com/80/v2-1d9906f57c60d8d8edca1df783cd9458_720w.jpg)

### 构建渲染树

当 DOM 树和 CSSOM 树都有了之后，就要开始构建渲染树了，一般来说，渲染树和 DOM 树是相对应的，但不是严格意义上的一一对应，因为有一些不可见的 DOM 元素不会插入到渲染树中，如 head 这种不可见的标签或者 display：none 等

整体，可以看图

![render树](https://pic1.zhimg.com/80/v2-1e04ec8a59e1818d24570ac0fefcf9cc_720w.jpg)

### 渲染

有了 render 树，接下来就是开始渲染，基本流程如下：

![渲染](https://pic2.zhimg.com/80/v2-0599b3c17ba850103cd0bd9145f5c8e5_720w.jpg)

重要的四个步骤是：

```
1. 计算CSS样式
2. 构建渲染树
3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性
4. 绘制，将图像绘制出来
```

然后图中的线与箭头代表通过 js 动态修改了 DOM 或 CSS，导致了重新布局（Layout）或渲染（Repaint）

这里的 Layout 和 Repaint 的概念是有区别的：

- Layout，也称为 Reflow，即回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
- Repaint,即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色），此时只需要应用新样式绘制这个元素就可以了

回流的成本开销要高于重绘，而且一个节点的回流往往会导致子节点以及同级节点的回流，所以优化方案一般都包括，尽量避免回流。

## CSS 的可视化格式模型

- 包含块（Containing Block）
- 控制框（Controlling Box）
- BFC（Block Formatting Context）
- IFC（Inline Formatting Context)
- 其它

## JS 引擎解析过程

- JS 的解析阶段
- JS 的预处理阶段
- JS 的执行阶段
- 回收机制

## 其它

## 总结

## 其它答案

::: details 其它答案

## 浏览器输入 URL 后发生了什么？

```text
话术：
大体上呢，可以分为六步
第一步，进行URL解析（合成URL）
第二步，进行DNS域名解析
第三步，建立TCP连接（三次握手）
第四步，发送HTTP请求，处理请求，返回响应结果
第五步，关闭TCP连接（四次挥手）
第六步，浏览器渲染
每一步都可以详细展开来说
首先第一步URL解析（合成URL），用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL。
```

1. 浏览器的地址栏输入 URL 并按下回车。
2. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期。
3. DNS 域名解析
4. 建立 TCP 连接
5. 发送 HTTP 请求
6. 服务器处理请求
7. 返回响应结果
8. 关闭 TCP 连接
9. 浏览器解析 HTML
10. 浏览器布局渲染

### 1.URL 解析

URL（本质是统一资源定位符，是用来定位网络资源的地址）一般包括几大部分：

- protocol，协议头，譬如有 http，加密的 https，ftp 等
- host，主机域名或 IP 地址
- port，端口号（通常端口号不常见是因为大部分的都是使用默认的端口所以隐藏，如 HTTP 默认端口 80，HTTPS 默认端口 443。）
- path，目录路径
- query，即查询参数
- fragment，即#后的 hash 值，一般用来定位到某个位置

其他面试官可能问的知识点：同源策略，跨域的问题（待补充）

**地址解析：**

首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。

**HSTS**

由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。

**其他操作**

浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。

**检查缓存**:判断是直接使用缓存内容还是重新向服务器请求资源

![img](https://img2018.cnblogs.com/blog/1312098/201909/1312098-20190925172652547-613981667.png)

![](https://upload-images.jianshu.io/upload_images/6007177-7e18e5017119a07b.png?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp)

### 2.DNS 域名解析

我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器 IP 地址这项工作，是由 DNS 服务器来完成的。

客户端收到你输入的域名地址后，它首先去找本地的 hosts 文件，检查在该文件中是否有相应的域名、IP 对应关系，如果有，则向其 IP 地址发送请求，如果没有，再去找 DNS 服务器。一般用户很少去编辑修改 hosts 文件。

我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与 IP 地址的一个映射。网络服务器的 IP 地址那么多，我们不可能去记一串串的数字，因此域名就产生了，**域名解析的过程实际是将域名还原为 IP 地址的过程**。
首先浏览器先检查本地 hosts 文件是否有这个网址映射关系，如果有就调用这个 IP 地址映射，完成域名解析。
如果没找到则会查找本地 DNS 解析器缓存，如果查找到则返回。
如果还是没有找到则会查找本地 DNS 服务器，如果查找到则返回。
最后迭代查询，按根域服务器 ->顶级域,.com->第二层域，[baidu.com](https://links.jianshu.com/go?to=http%3A%2F%2Fbaidu.com) ->子域，[www.baidu.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.baidu.com)的顺序找到 IP 地址。

客户端和浏览器，本地 DNS 之间的查询方式是递归查询；

本地 DNS 服务器与根域及其子域之间的查询方式是迭代查询

### 3.TCP 连接

通过 DNS 域名解析后，获取到了服务器的 IP 地址，在获取到 IP 地址后，便会开始建立一次连接，这是由 TCP 协议完成的，主要通过三次握手建立 TCP 连接。

首先，判断是不是 https 的，如果是，则 HTTPS 其实是 HTTP + SSL / TLS 两部分组成，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。

1. 第一次握手：建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；
2. 第二次握手：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时，自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态；
3. 第三次握手：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。

完成三次握手，客户端与服务器开始传送数据。

![img](https:////upload-images.jianshu.io/upload_images/6007177-5236f2db046d5ed7.png?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp)

SSL 握手过程

1. 第一阶段 建立安全能力 包括协议版本 会话 Id 密码构件 压缩方法和初始随机数
2. 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
3. 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
4. 第四阶段 变更密码构件和结束握手协议

### 4. 浏览器向服务器发送 HTTP 请求

TCP 连接建立后，浏览器就可以利用 HTTP/HTTPS 协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如 if-none-match 与 if-modified-since，则验证缓存是否有效，若有效则返回状态码 304，若无效则重新返回资源，状态码为 200

与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：

请求行包括请求方法、URI、HTTP 版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。

完整的 HTTP 请求包含请求起始行、请求头部、请求主体三部分。

![img](https:////upload-images.jianshu.io/upload_images/6007177-fd41ce37067a1672.png?imageMogr2/auto-orient/strip|imageView2/2/w/892/format/webp)

常用的请求头部（部分）

```css
Accept: 接收类型，表示浏览器支持的MIME类型
（对标服务端返回的Content-Type）
Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
Content-Type：客户端发送出去实体内容的类型
Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
Cookie: 有cookie并且同域访问时会自动带上
Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
Host：请求的服务器URL
Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
User-Agent：用户客户端的一些必要信息，如UA头部等
```

### 5.服务器处理请求

服务器端收到请求后的由 web 服务器（准确说应该是 http 服务器）处理请求，诸如 Apache、Ngnix、IIS 等。web 服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过 web 服务器返回给浏览器客户端。

### 6.返回响应结果

浏览器接收到来自服务器的响应资源后，会对资源进行分析。

首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。

如果响应资源进行了压缩（比如 gzip），还需要进行解压。

然后，对响应资源做缓存。

接下来，根据响应资源里的 MIME[3] 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。

服务器在收到浏览器发送的 HTTP 请求之后，会将收到的 HTTP 报文封装成 HTTP 的 Request 对象，并通过不同的 Web 服务器进行处理，处理完的结果以 HTTP 的 Response 对象返回，主要包括状态码，响应头，响应报文三个部分。
状态码主要包括以下部分

- 1xx：指示信息–表示请求已接收，继续处理。
- 2xx：成功–表示请求已被成功接收、理解、接受。
- 3xx：重定向–要完成请求必须进行更进一步的操作。
- 4xx：客户端错误–请求有语法错误或请求无法实现。
- 5xx：服务器端错误–服务器未能实现合法的请求。
  响应头主要由 Cache-Control、 Connection、Date、Pragma 等组成。
  响应体为服务器返回给浏览器的信息，主要由 HTML，css，js，图片文件组成。

- 常用的响应头部（部分）：

```dart
Access-Control-Allow-Headers: 服务器端允许的请求Headers
Access-Control-Allow-Methods: 服务器端允许的请求方法
Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
Content-Type：服务端返回的实体内容的类型
Date：数据从服务器发送的时间
Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
Last-Modified：请求资源的最后修改时间
Expires：应该在什么时候认为文档已经过期,从而不再缓存它
Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
ETag：请求变量的实体标签的当前值
Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
Server：服务器的一些相关信息
```

在响应结果中都会有个一个 HTTP 状态码，比如我们熟知的 200、301、404、500 等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。

状态码由 3 位数字和原因短语组成。根据首位数字，状态码可以分为五类：

|     |       类别       |          原因短语          |
| :-: | :--------------: | :------------------------: |
| 1xx |   信息性状态码   |     接收的请求正在处理     |
| 2xx |    成功状态码    |      请求正常处理完毕      |
| 3xx |   重定向状态码   | 需要进行附加操作以完成请求 |
| 4xx | 客户端错误状态码 |     服务器无法处理请求     |
| 5xx | 服务器错误状态码 |     服务器处理请求出错     |

### 7.关闭 TCP 连接或继续保持连接

为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建 TCP 连接的 3 次握手类似，关闭 TCP 连接，需要 4 次握手。

通过四次挥手关闭连接（FIN ACK,ACK,FIN ACK,ACK）。

- 第一次挥手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number,向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；
- 第二次挥手：主机 2 收到了主机 1 发送的 FIN 报文段向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；
- 第三次挥手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态
- 第四次挥手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME——WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。

**`备注`**

ACK：此标志表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0。TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1。

SYN(SYNchronization)：在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。

FIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

### 8.浏览器解析 HTML(页面渲染-浏览器渲染)

准确地说，浏览器需要加载解析的不仅仅是 HTML，还包括 CSS、JS。以及还要加载图片、视频等其他媒体资源。

按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图：

1. 浏览器通过渲染进程将 HTML 内容转换为能够读懂 DOM 树结构（解析 HTML，生成 DOM 树）。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。（解析 CSS，生成 CSS 规则树）
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。
6. 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

```
解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。
```

要注意的是，浏览器的解析过程并非是串连进行的，比如在解析 CSS 的同时，可以继续加载解析 HTML，但在解析执行 JS 脚本时，会停止解析后续 HTML，这就会出现阻塞问题，关于 JS 阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。

不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。

Trident--Blink--Webkit--Gecko

![](https://img2018.cnblogs.com/blog/1312098/201909/1312098-20190925173030325-2111237777.png)

#### 1.HTML 解析

首先要知道浏览器解析是从上往下一行一行地解析的。解析的过程可以分为四个步骤：

**① 解码（encoding）**

传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。

**② 预解析（pre-parsing）**

预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如`img`标签的`src`属性，并将这个请求加到请求队列中。

**③ 符号化（Tokenization）**

符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。它通过一个状态机去识别符号的状态，比如遇到`<`，`>`状态都会产生变化。

**④ 构建树（tree construction）**

> 注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。

在上一步符号化中，解析器获得这些标记，然后以合适的方法创建`DOM`对象并把这些符号插入到`DOM`对象中。

```html
<html>
  <head>
    <title>Web page parsing</title>
  </head>
  <body>
    <div>
      <h1>Web page parsing</h1>
      <p>This is an example Web page.</p>
    </div>
  </body>
</html>
```

![](https://img2018.cnblogs.com/blog/1312098/201909/1312098-20190925173115611-744130156.png)

**浏览器容错进制**

你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。

**事件**

当整个解析的过程完成以后，浏览器会通过`DOMContentLoaded`事件来通知`DOM`解析完成。

#### 2. CSS 解析

一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范[4]解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。

**CSS 匹配规则**

在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：`div p { font-size :14px }`会先寻找所有的`p`标签然后判断它的父元素是否为`div`。所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。

#### 3.渲染树

其实这就是一个 DOM 树和 CSS 规则树合并的过程。

> 注意：渲染树会忽略那些不需要渲染的节点，比如设置了`display:none`的节点。

**计算**

通过计算让任何尺寸值都减少到三个可能之一：`auto`、百分比、px，比如把`rem`转化为`px`。

**级联**

浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做`specificity`的公式，这个公式会通过：

1. 标签名、class、id
2. 是否内联样式
3. `!important`

然后得出一个权重值，取最高的那个。

**渲染阻塞**

当遇到一个`script`标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。

但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。

所有我们知道：

- - CSS 会阻塞 JS 执行
  - JS 会阻塞后面的 DOM 解析

为了避免这种情况，应该以下原则：

- - CSS 资源排在 JavaScript 资源前面
  - JS 放在 HTML 最底部，也就是 `</body>`前

另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：这篇文章[5]

#### 4. 布局与绘制

确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。

然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。

#### 5.合并渲染层

把以上绘制的所有图片合并，最终输出一张图片。

#### 6. 回流与重绘

**回流(reflow)**

当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从`html`标签开始递归往下，重新计算位置和大小。

reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。

**重绘(repaint)**

改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。

每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。

回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。

比如：

- - `display:none` 会触发回流，而 `visibility:hidden` 只会触发重绘。

#### 7. JavaScript 编译执行

**大致流程**

![](https://img2018.cnblogs.com/blog/1312098/201909/1312098-20190925173144784-1551861760.png)

可以分为三个阶段：

##### 1. 词法分析

JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。

几个步骤：

- - 分词，例如将`var a = 2`，，分成`var`、`a`、`=`、`2`这样的词法单元。
  - 解析，将词法单元转换成抽象语法树（AST）。
  - 代码生成，将抽象语法树转换成机器指令。

##### 2. 预编译

JS 有三种运行环境：

- - 全局环境
  - 函数环境
  - eval

每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。

**创建执行上下文**

创建执行上下文的过程中，主要做了以下三件事：

- 创建变量对象

- - 参数、函数、变量

- 建立作用域链

- - 确认当前执行环境是否能访问变量

- 确定 This 指向

##### 3. 执行

**JS 线程**

![](https://img2018.cnblogs.com/blog/1312098/201909/1312098-20190925173204648-1720259215.png)

虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：

> 其中三个只是协助，只有 JS 引擎线程是真正执行的

- JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎
- 事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行
- 定时器触发线程：主要控制`setInterval`和`setTimeout`，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。
- HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。

**注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。**

**宏任务**

分为：

- - 同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务
  - 异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。

**微任务**

微任务是 ES6 和 Node 环境下的，主要 API 有：`Promise`，`process.nextTick`。

微任务的执行在宏任务的同步任务之后，在异步任务之前。

![](https://img2018.cnblogs.com/blog/1312098/201909/1312098-20190925173222536-633088783.png)

**代码例子**

```javascript
console.log("1"); // 宏任务 同步

setTimeout(function() {
  console.log("2"); // 宏任务 异步
});

new Promise(function(resolve) {
  console.log("3"); // 宏任务 同步
  resolve();
}).then(function() {
  console.log("4"); // 微任务
});

console.log("5"); // 宏任务 同步
```

以上代码输出顺序为：1,3,5,4,2

### 9.浏览器布局渲染

根据渲染树布局，计算 CSS 样式，即每个节点在页面中的大小和位置等几何信息。HTML 默认是流式布局的，CSS 和 js 会打破这种布局，改变 DOM 的外观样式以及大小和位置。这时就要提到两个重要概念：replaint 和 reflow。

replaint：屏幕的一部分重画，不影响整体布局，比如某个 CSS 的背景色变了，但元素的几何尺寸和位置不变。

reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是 Reflow，或是 Layout。

所以我们应该尽量减少 reflow 和 replaint，我想这也是为什么现在很少有用 table 布局的原因之一。

最后浏览器绘制各个节点，将页面展示给用户。

:::
