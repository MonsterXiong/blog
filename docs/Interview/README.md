---
sidebar: auto
---

# 面试

## 自我介绍

::: details 自我介绍
面试官，你好
我叫 XXX，从 xx 年 xx 月开始实习到目前为止已经参加工作 xx 年，先后在 xx，xx 公司实习，毕业后来到现在这家公司，一直工作到现在，目前我在公司主要负责的是小程序、后台管理系统项目的开发以及推动团队工程化和基础建设等，个人比较擅长的技术有 Vue，原生 JS，一些常用的打包构建工具，熟悉 nodejs，服务器也懂一点；然后平时我会关注前端领域一些前沿技术的发展，偶然写点博客，方便自己快速查找，以上就是我的自我介绍！

:::

## 答题技巧

::: details 答题技巧
例子：盒子水平垂直居中的五大方案

- 定位 3 种
- display:flex
- JS
- display:table-cell

* 切勿背水式回答

这种需求在我之前的项目当中是非常常见的，刚开始我只用了这种这种这种，虽然兼容性不好，但实现起来更好，后来随着 CSS3 的兴起，Flex 这种方式非常方便，尤其是在移动端开发的时候来实现的话，特别强大，有一段时间，看掘金看博客的时候，发现这种方案虽然不常用，但也能实现，我感觉挺好玩的，所以就记下来了
:::

## 项目描述

::: details 项目描述

> 面试官：你说下你这个项目吧。

> 我：这个项目采用的是 vue 的技术栈，项目需要推广到市场，要进行 seo。所以项目做了一个 ssr。在项目有一整套自己定义的工程化流程，来规范开发过程。项目的数据量展示很大，所以做了数据懒加载，以及很多地方做了数据缓存。

> 面试官：那你说下你是怎么做的 seo，还有数据缓存是怎么做的？

> 我：整体的 seo 采用了 nuxt 为基础框架，node 端也加入了一些中间件。缓存这一块我举个例子，我们做了一个 api 数据自动缓存，api 的数据有缓存的话，就会自动从缓存拿。最大程度的做到复用缓存。

> 面试官：很好，技术没问题，我去和人资说下。

:::

## 项目亮点

::: details 项目亮点

### 概要

- 使用 gulp 构建小程序的代码包
- 基于 redis 实现的锁（用于控制 nodejs 的并发）
- 前端错误监控系统
- 前端性能监控系统
- 落地页截图(Node 项目)
- 大前端：Nosql 数据库设计和集成，JWT 登录鉴权，消息中间件开发，基于角色&菜单权限设计，可视化图表和日志服务

小程序分包
容器化开发
SSR

### 使用 gulp 构建小程序的代码包

在开发小程序项目的过程中，由于功能的不断增加导致了代码包体积的越来越大。相对其体积进行一下压缩处理，看了几篇给小程序瘦身的博客，决定给自己的项目做一套配置文件，使用 gulp 来支持小程序文件的编译以及上传之前压缩文件的空行之类的。（微信）

### 基于 redis 实现的锁（用于控制 nodejs 的并发）

场景：使用 node+mongo 搭建 web 应用时，常常遇到并发问题导致创建一条数据的时候会同时创建多条。

通过 redis set 方法 配合 ‘NX’ 选项即可实现锁机制。

### 压力测试

autocannon

### 系统监控

### 日志系统

### 前端错误监控系统(基建)(负责人) 接入量 pv:3000w

- web 端 js-sdk 开发,无侵入式接入,压缩后仅 2kb。
- 收集端 Node 开发,分布式存储日志。
- 阿里云日志服务分析,以及常用的数据分析。
- echart 搭建可视化平台。

### 前端性能监控系统(负责人) 接入 pv: 1000w

- web 端 js-sdk 开发,支持自定义上报以及自动上报,无侵入式。
- 收集端 Node 开发,Elasticsearch 集群存储日志。
- Elasticsearch 的 Node 模块开发，封装按时间维度的查询聚合模块。
- 可视化平台,利用 redis 缓存优化查询,淘汰算法共同协作。

### 前端监控系统

- 客户端监控载体端以及数据脚本开发
- 基于 highcharts 的可视化图形界面开发
- 平台的性能统计模块以及告警模块开发
- 高并发下的 redis 设计以及错误信息识别过滤处理

### 落地页截图(Node 项目)

- 利用 puppeteer 开发截图。
- 利用 clustor 多线程开发,速度从原来 60 分钟提高至 8 分钟，提高约 7 倍（300 张截图）。
- 开发自定义队列模式,避免 Node 端丢失请求。
  :::

## 从输入 URL 到页面加载的过程

### 从浏览器接受 url 到开启网络请求线程

- 多进程的浏览器
- 多线程的浏览器内核
- 解析 URL
- 网络请求都是单独的线程
- 更多

::: details 展开
**浏览器的进程/线程模型，JS 的运行机制**

#### 多进程的浏览器

浏览器是多进程的，有一个主控进程，以及每一个 tab 页面都会新开一个进程（某些情况下多个 tab 会合并进程）

进程可能包含主控进程，插件进程，GPU，tab 页（浏览器内核）等等

- Browser 进程：浏览器的主进程（负责协调、主控），只有一个
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时创建
- GPU 进程：最多一个，用于 3D 绘制
- 浏览器渲染进程（内核）：默认每个 Tab 页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 tab 会合成一个进程）

#### 多线程的浏览器内核

每一个 tab 页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几类子线程

- GUI 渲染线程
- JS 引擎线程
- 事件触发线程
- 定时触发器线程
- 异步 http 请求线程（网络请求线程）

可以看到，JS 引擎是内核进程的一个线程，所以 JS 引擎是单线程的

#### 解析 URL

输入 URL 后，会进行解析（URL 的本质就是统一资源定位符）

URL 一般包含几大部分：

- protocol,协议头，譬如有 http，ftp 等
- host，主机域名或 IP 地址
- port，端口号
- path,目录路径
- query，查询参数
- fragment：#后的 hash 值，一般用来定位到某个位置

#### 网络请求都是单独的线程

每次网络请求时都需要开辟单独的线程进行，譬如如果 URL 解析到 http 协议，就会新建一个网络线程去处理资源下载

因此浏览器会根据协议出的协议，开辟一个网络线程，前往请求资源

#### 更多

[从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)

:::

### 开启网络请求线程到发出一个完整的 http 请求

- DNS 查询得到 IP
- tcp/ip 请求
- 五层因特网协议栈

::: details 展开

#### DNS 查询得到 IP

如果输入的是域名，需要进行 DNS 解析成 IP，大致流程：

- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，没有的话就用 host
- 如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP

注意，域名查询是有可能是经过了 CDN 调度器的（如果有 cdn 存储功能的话）
而且，需要知道 dns 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 dns-prefetch 优化

#### tcp/ip 请求

http 的本质就是 tcp/ip 请求

需要了解 3 次握手建立连接以及断开连接时的四次挥手

tcp 将 http 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输

三次握手的步骤：（抽象派）

```
客户端：hello，你是server吗？
服务端：hello,我是server，你是client吗？
客户端：yes，我是client
```

建立连接成功后，接下来就正式传输数据

然后，待到断开连接时，需要进行四次挥手（因为时全双工的，所以需要四次挥手）

四次挥手的步骤：（抽象派）

```
主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
被动方：收到通道关闭的信息
被动方：那我也告诉你，我这边向你的主动通道也关闭了
主动方：最后收到数据，之后双方无法通信
```

#### tcp/ip 的并发限制

浏览器对同一域名下并发的 tcp 连接是有限制的（2-10 个不等）

而且在 http1.0 中往往一个资源下载就需要对应一个 tcp/ip 请求

针对这个瓶颈，又出下了很多资源优化方案

#### get 和 post 的区别

get 和 post 虽然本质都是 tcp/ip，但两者除了在 http 层面外，在 tcp/ip 层面也有区别。
get 会产生一个 tcp 数据包，post 两个

具体就是：

- get 请求时，浏览器会把 headers 和 data 一起发送出去，服务器响应 200（返回数据）
- post 请求时，浏览器先发送 headers，服务器响应 100 continue，浏览器再发送 data，服务器响应 200（返回数据）

这里的区别时 specification（规范）层面，而不是 implementation（对规范的实现）

#### 五层因特网协议栈

从客户端发出 http 请求到服务器接收，中间会经过一系列的流程

从应用层的发送 http 请求，到传输层建立三次握手建立 tcp/ip 连接，再到网络层的 ip 寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输

服务端的接收就是反过来的步骤

五层因特网协议栈其实就是：

```
1. 应用层（dns，http）DNS解析成IP并发送http请求
2. 传输层（tcp,udp）建立tcp连接（三次握手）
3. 网络层（IP，ARP）IP寻址
4. 数据链路层（PPP）封装成帧
5. 物理层（利用物理介质传输比特流）物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

```

还有一个完成的 OSI 七层框架，与之相比，多了会话层、表示层。

OSI 七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

```
表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等

会话层：它具体管理不同用户和进程之间的对话，如控制登录和注销过程。
```

:::

### 从服务器接收到请求到对应后台接收到请求

- 负载均衡
- 后台的处理

::: details 展开

服务端在接收到请求时，内部会进行很多的处理

#### 负载均衡

对于大型项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡

简单地说：
用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户

#### 后台的处理

一般后台都是部署到容器中的，所以一般为：

- 先是容器接收到请求（如 tomcat 容器）
- 然后对应容器中的后台程序接收到请求（如 java 程序）
- 然后就是后台会有自己的统一处理，处理完后响应结果

概括下：

- 一般有的后端是有统一的验证的，如安全拦截，跨域验证
- 如果这一步不符合规则，就会直接返回相应的 http 报文（如拒绝请求等）
- 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
- 等程序执行完毕后，就会返回一个 http 响应包（一般这一步也会经过多层封装）
- 然后就是将这个包从后端发送到前端，完成交互
  :::

### 后台和前台的 http 交互

- http 报文结构
- cookie 以及优化
- gzip 压缩
- 长连接与短连接
- http2.0
- https

::: details 后台和前台的 http 交互
前后端交互时，http 报文作为信息的载体

#### http 报文结构

报文一般包括了：通用头部，请求/响应头部，请求/响应体

---- 待更新

#### cookie 以及优化

---- 待更新

#### gzip 压缩

---- 待更新

#### 长连接与短连接

---- 待更新

#### http2.0

---- 待更新

#### https

---- 待更新
:::

### 缓存问题-http 的缓存

- 强缓存与弱缓存
- 缓存头部简述
- 头部的区别

### 解析页面流程

- 流程简述
- HTML 解析，构建 DOM
- 生成 CSS 规则
- 构建渲染树
- 渲染
- 简单层与复合层
- Chrome 中的调试
- 资源外链的下载
- loader 和 domcontentloaded

::: details 展开

#### 流程简述

浏览器内核拿到内容后，渲染步骤大致可以分为一下几步：

```
1. 解析HTML树，构建DOM树
2. 解析CSS，生成CSS规则树
3. 合并DOM树和CSS规则，生成render树
4. 布局render树（Layout/reflow），负责个元素尺寸、位置的计算
5. 绘制render树（paint）,绘制页面像素信息
6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

```

HTML 解析，构建 DOM 树
整个渲染步骤中，HTML 解析是第一步

解析 HTML 到构建出 DOM 过程可以简述如下：

```
Bytes => characters => tokens => nodes => DOM
```

譬如假设有这样一个 HTML 页面：

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
```

浏览器的处理如下：
![解析HTML](https://pic4.zhimg.com/80/v2-83fcb412ec495490e5cde63dbee3bda3_720w.jpg)

列举其中的一些重点过程：

```
1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符
2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集
3. Lexing词法分析：分析的结果是得到一堆token，此时把他们转换成对象，这些对象分别定义他们的属性和规则
4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
例如：body对象的父节点就是HTML对象，然后段落P对象的父节点就是body对象
```

#### 生成 CSS 规则

CSS 规则树的生成也是类似，简述为：

```
Bytes => characters => tokens => nodes => CSSOM
```

譬如 style.css 内容如下：

```css
body {
  font-size: 16px;
}
p {
  font-weight: bold;
}
span {
  color: red;
}
p span {
  display: none;
}
img {
  float: right;
}
```

最终的 CSSOM 树就是：
![CSSOM树](https://pic1.zhimg.com/80/v2-1d9906f57c60d8d8edca1df783cd9458_720w.jpg)

#### 构建渲染树

当 DOM 树和 CSSOM 树都有了之后，就要开始构建渲染树了，一般来说，渲染树和 DOM 树是相对应的，但不是严格意义上的一一对应，因为有一些不可见的 DOM 元素不会插入到渲染树中，如 head 这种不可见的标签或者 display：none 等

整体，可以看图

![render树](https://pic1.zhimg.com/80/v2-1e04ec8a59e1818d24570ac0fefcf9cc_720w.jpg)

#### 渲染

有了 render 树，接下来就是开始渲染，基本流程如下：

![渲染](https://pic2.zhimg.com/80/v2-0599b3c17ba850103cd0bd9145f5c8e5_720w.jpg)

重要的四个步骤是：

```
1. 计算CSS样式
2. 构建渲染树
3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性
4. 绘制，将图像绘制出来
```

然后图中的线与箭头代表通过 js 动态修改了 DOM 或 CSS，导致了重新布局（Layout）或渲染（Repaint）

这里的 Layout 和 Repaint 的概念是有区别的：

- Layout，也称为 Reflow，即回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
- Repaint,即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色），此时只需要应用新样式绘制这个元素就可以了

回流的成本开销要高于重绘，而且一个节点的回流往往会导致子节点以及同级节点的回流，所以优化方案一般都包括，尽量避免回流。

:::

### CSS 的可视化格式模型

- 包含块（Containing Block）
- 控制框（Controlling Box）
- BFC（Block Formatting Context）
- IFC（Inline Formatting Context)
- 其它

### JS 引擎解析过程

- JS 的解析阶段
- JS 的预处理阶段
- JS 的执行阶段
- 回收机制

### 其它

### 总结
