# Redis

## 什么是 Redis？

- Remote Dictionary Server （远程字典服务器）
- Redis 是一个开源的使用 C 语言编写的数据库
- 不同的是 MongoDB 存储的是文档，而 Redis 存储的是键值对（Key-Value）

## Redis 特点

- 速度快

  - Redis 默认情况下将数据存储在内存中
  - 读取速度能达到 10 万次/s 左右，写入能达到 8 万次/s 左右

- 支持数据的持久化

  - 可以将内存中的数据保存到磁盘中

- 支持多种数据结构

  - Redis 是通过 key-value 形式存储数据的，但是 value 的值除了支持常用数据类型以外，同时还提供了 list，set，zset，hash 等数据结构的存储

- 定制性强

  - Redi 虽然强大，但是它是开源免费的
  - Redis 第一个版本代码在 23000 行代码左右
  - Redis 当前版本代码在 50000 行左右（代码少，阅读起来比较方便，定制起来就比较简单）

- 支持分布式

  - 和 MongoDB 一样，Redis 是支持主从复制，支持分布式存储的

## Redis 常见应用场景

- 缓存系统
  - 由于 Redis 是将数据存储在内存中，所以我们可以使用 Redis 来实现内存缓存
  - 对于经常会被查询，但是不经常被修改或者删除的数据，存储到 Redis 中
- 排行榜
  - 由于 Redis 支持集合（Set）和有序集合（Sorted Set）,所以我们在实现排行榜的时候变得非常简单
- 计数器
  - 由于 Redis 提供了 incr/decr 指令，使得我们在实现计数器时非常简单
  - 转发数/评论数/播放数/访问数。。。
- 存储社交关系
  - 由于 Redis 支持存储集合类型数据，由于社交关系不会经常发生改变，所以很多社交网站会使用 Redis 来存储社交关系
- 消息队列系统
  - Redis 天生支持发布订阅模式，所以天生就是实现消息队列系统的材料

## 发布订阅

在发布订阅中有三个角色：发布者/订阅者/频道，只要发布者将消息发送到对应的频道中，那么所有的订阅者都能收到这个消息，这个就是 Redis 的发布订阅。

- 订阅
  - subscribe channel [channel...]
- 发布消息
  - publish channel message
- 退订频道
  - unsubscribe [channel [channel ...]]

## Redis 持久化方式

- 默认情况下 Redis 是将数据保存在内存中的，保存在内存中的数据有一个特点，那就是机器重启之后数据就会丢失。
- 所以为了避免服务器重启死机等问题发生的时候，Redis 中保存的数据丢失 ，Redis 提供了数据持久化功能

什么是数据持久化？

- 数据持久化就是将内存中的数据写入磁盘中
- Redis 和大部分主流数据库(MySQL/MongoDB/...)一样，支持 RDB 和 AOF 持久化

## RDB

Redis DataBase：持久化内存数据到磁盘

Redis 服务端 fork 一个子进程，定时并且达到触发修改次数的时候写磁盘，写到 RDB 文件。

### 如何生成 RDB 文件

触发生成 RDB 三种机制

- 手动执行 save 命令
  - 同步执行
  - 如果已经存在旧的 RDB 文件，会利用新的覆盖旧的
  - 多次执行会先在临时文件保存然后再进行覆盖
- 手动执行 bgsave 命令
  - 异步执行
  - 如果已经存在就的 RDB 文件，会利用新的覆盖旧的
- 通过配置文件自动生成
  - 通过配置文件指定自动生成条件，一旦满足条件就会自动执行 bgsave 生成 RDB 文件

```sh
dir ./ #RDB文件保存的路径
dbfilename dump.rdb #RDB文件的名称
# save 900 1 #自动生成条件
# save 300 10
# save 60 10000
stop-writes-on-bgsave-error yes #bgsave发生错误是否停止写入
rdbcompression yes #是否采用压缩模式写入
rdbchecksum yes #是否对生成的RDB文件进行校验

# 自动生成弊端
# 无法控制生成的频率，如果频率过高会导致性能消耗较大
```

### RDB 推荐配置

```sh
dir /rdbdiskpath                #由于备份是比较占用磁盘空的, 所以推荐使用一个比较大的磁盘路径
dbfilename dump-${prot}.rdb     #由于一台服务器上可能部署多个Redis, 所以可以给RDB文件添加端口号作为区分
stop-writes-on-bgsave-error yes #bgsave发生错误是否停止写入
rdbcompression yes              #是否采用压缩模式写入
rdbchecksum yes                 #是否对生成的RDB文件进行校验
```

### RDB 存在的问题

- 不可控、数据丢失
  - 服务器当即之前的数据，如果未写入 RDB 文件就会丢失

```sh
set name monster
save  or basave  or 自动保存
set name zs
# 宕机
```

- 耗时、耗性能
  - RDB 是一次性把内存中所有的内容写入磁盘中，是一个 比较重的操作，如果需要写入的数据比较多，那么就比较耗时
  - RDB 每次都是把内存中的 所有内容 全部写入到磁盘中，哪怕内存中的数据已经写入过了也会再次完整写入，重复写入相同的 数据，也比较浪费 I/O 资源
  - 如果通过 save 命令写入，会阻塞后续命令执行。如果通过 bgsave 写入，不会阻塞后续命令执行 ，会开启子进程去专门负责写入，但是开启子进程会消耗内存空间

## AOF

Append Only File：持久化修改数据的命令

由客户端发起修改命令到 Redis 服务端，每秒/每个命令/不同步的方式到 AOF 文件。

### 如何生成 AOF

- always
  - 每条命令都写入一条命令到文件中
  - 优点：不会 丢失数据
  - 缺点：磁盘 I/O 消耗较大
- everysec
  - 每隔一秒写入一次，也就是先收集 1 秒钟的命令，然后再一次性写入到文件中
  - 优点：磁盘 I/O 消耗相对较小
  - 缺点：可能丢失 1 秒数据
- no
  - 让操作系统决定什么时候写入，操作系统想什么时候写入就什么什么 时候写入
  - 不可控，可能丢失大量数据

```sh
# 配置文件中
appendfsync everysec
```

### AOF 重写

- 随着时间的推移 AOF 文件会越来越大，会带来以下问题
  - 磁盘消耗越来越大
  - 写入速度会越来越慢
  - 恢复的时间越来越慢
- 所以 AOF 提供了重写的机制，我们可以对 AOF 文件中保存的内容进行优化
  - 从而降低文件的体积
  - 从而提升文件的恢复速度
- 在 AOF 的重写机制中
  - 可以将自动去除冗余命令
  - 可以自动删除没有用的命令

```diff
+ 优化前：set name monster; set name zs;set name ls;
+ 优化后：set name ls;
+ 优化前：incr conunt;incr count;
+ 优化后：set count 2;
+ 优化前：expire name 3
+ 优化后：3秒后由于数据已经被删除，所以这条命令不用保存

```

### 触发 AOF 重写两种机制

- bgrewriteaof 命令
  - 开启一个新的子进程，根据内容中的数据生成命令写入到 AOF 文件中
- 配置文件设置

```sh
auto-aof-rewrite-min-size 200mb #AOF文件体积达到多大时进行重写
auto-aof-rewrite-percentage 100 #对比上一次重写否，增长了百分之多少再次进行重写
								#例如上一次重写大小后是100MB，如果设置50，那么下一次就是增长0.5倍（150）再重写
								#例如上一次重写大小是100MB，如果设置100，那么下一次就是增长两倍（200）再重写
```

### AOF 推荐配置

```sh
appendonly yes                           #是否使用AOF
appendfilename "appendonly-${prot}.aof"  #AOF文件名称
appendfsync everysec                     #写入命令的同步机制
dir /rdbdiskpath                         #保存AOF文件路径
auto-aof-rewrite-min-size 64mb           #AOF文件重写体积
auto-aof-rewrite-percentage 100          #AOF文件增长率
no-appendfsync-on-rewrite yes            #AOF重写时是否正常写入当前操作的命令(追求性能yes，追求数据安全性no)
```

## RDB vs AOF

|                | RDB            | AOF            |
| -------------- | -------------- | -------------- |
| 保存内容       | 二进制数据文件 | Redis 命令     |
| 数据恢复速度   | 快照恢复速度快 | 命令过多速度慢 |
| 数据恢复完整性 | 可能丢数据     | 比 RDB 高      |

- AOF 优先级高于 RDB
  - 如果 Redis 服务器同时开启了 RDB 和 AOF, 那么宕机重启之后会优先从 AOF 中恢复数据
- RDB 体积小于 AOF
  - 由于 RDB 在备份的时候会对数据进行压缩, 而 AOF 是逐条保存命令, 所以 RDB 体积比 AOF 小
- RDB 恢复速度比 AOF 恢复速度快
  - 由于 AOF 是通过逐条执行命令的方式恢复数据, 而 RDB 是通过加载预先保存的数据恢复数据
    所以 RDB 的恢复速度比 AOF 快
- AOF 数据安全性高于 RDB
  - 由于 AOF 可以逐条写入命令, 而 RDB 只能定期备份数据, 所以 AOF 数据安全性高于 RDB
- 所以综上所述, 两者各有所长, 两者不是替代关系而是互补关系

## 如何能够最大化保证恢复数据的速度及数据的完整性呢？

Redis4.0 以后推出混合持久化的方式，以 RDB 的方式全量持久化内存数据，保证数据恢复的速度并以增量的方式持久化修改命令，保证数据的完整性。最终以 RDB 和 AOF 共存的方式写入 AOF 文件。

## Redis 架构模式

### 单机模式

指的是缓存服务中只有一台 Redis 对我们的应用提供读写服务，因为只有一台 Redis，缺点比较明显，Redis 宕机时应用就无法使用，并且只有一台 Redis，吞吐量比较低。

### 主从模式

指的是缓存服务中有一台主和多台从 Redis，主 Redis 提供写，从 Redis 提供读，实现读写分离，减轻单台 Redis 的压力，但是主 Redis 宕机时，需要手动去选择从 Redis，也是不可用的。

### 哨兵模式

指的是缓存服务中仍然有主从 Redis 对外提供服务，并且有哨兵去监控主从 Redis 的状态，如果主 Redis 发生宕机，就会从从 Redis 中自动选择一台对外提供服务，这种模式可以解决可用性问题，但是只有一台 Redis 对外提供写服务，大量写仍然会有问题，所以引入集群模式解决可用性和吞吐量大的问题。

### 集群模式

是通过多个独立的主从 Redis 对外提供服务，解决可用和吞吐量问题，但应用具体读写哪一台主从，集群模式下有 16384 个 hash slot 分别分布在主从上，根据 key 计算出哈希槽的位置确定在哪一个主从。

## 什么是分布式锁？

比如有多个服务端，A、B、C 经过分布式锁对共有资源进行访问，只有 A 可以成功，B 和 C 失败，这种在分布式系统中控制多个进程对共有资源的访问成为分布式锁。

## 分布式锁具有的性质

互斥性：同一时刻，只有一个客户端可以获取锁。

安全性：锁的获取和释放是同一个客户端。

可用性：高可用的分布式锁系统及避免产生死锁

## 怎样用 Redis 实现分布式锁？

### setnx+expire 加锁

setnx 如果 key 不存在 set 成功返回 1，失败返回 0，保证互斥；

expire 设置过期时间，防止锁的长期持有或死锁。

但这种方式是不正确的，因为 setnx 和 expire 直接会发生异常导致死锁。

### set 原子方法加锁

```sh
SET key value NX EX expire-time

# 直接使用set方法进行加锁，避免死锁。NX和EX为固定值，前者表示SET IF NOT Exist，后者表示添加过期时间，具体时间取最后一个参数
```

该方法出现在 Redis2.6.12 以后，可以直接将 set 方法和设置过期时间统一成一个原子操作，避免产生死锁。

### 比较删除解锁

在通过比较删除进行解锁，删除 key 之前，判断是否为加锁的客户端，如果是则删除，如果不是则不删除，保证安全性。

```sh
DEL key
# 删除之前判断是否为加锁的客户端，可以通过添加客户端的唯一id（具体实现自己决定）到value中，每次删除前比较，一致再进行删除解锁，保证安全性
```

## 缓存的使用场景

当用户使用我们的网站/APP 时，他们操作的数据基本来源于我们底层的数据库，那么当用户量比较大的时候，数据库的读写压力也会随之增加，一般情况下，我们会缓存一下热点数据，缓存数据的目的是，一方面可以让网站/APP 可以直接从缓存拿数据，有更快的响应；另一方面，可以减轻数据库的负担，Redis 就是常用的缓存数据库

## 缓存存在的问题

其实只有一个，不可用问题。当缓存不可用时，用户的请求最后会落在 DB 上，在高并发或者有人恶意攻击的情况下，有可能导致 DB 崩溃。缓存中可能会出现问题的情况。

### 缓存穿透

当用户访问了一个本身就不存在的缓存，那么用户的请求最终会落在 DB 上，那么在高并发或者有人恶意攻击的情况下，就会产生之前所说的问题。

解决方法：

1. 使用布隆过滤器判断缓存中是否存在。
2. 为请求设置一个值为 null 的缓存，设置较短的过期时间。

### 缓存击穿

当用户访问缓存数据库，发现缓存已经过期失效，那么就要去 DB 重新拿缓存并且写入缓存数据库，如果在这时有高并发的请求，就会导致瞬间 DB 压力过大。

解决方法：

1. 热点数据的缓存永不过期，可以解决瞬间数据库压力过大的问题。
2. 采用分布式锁，缓存失效后只有一个线程更新并写入缓存数据库。

### 缓存雪崩

大面积的缓存击穿或服务不可用就成为缓存雪崩。

解决方式：

1. 使用 Redis 哨兵或集群等架构提升可用性。
2. 采用和缓存击穿一样的方式。
3. 错开缓存数据的过期时间点，防止缓存大面积失效。

## Redis 主从复制的实现原理

### 主从复制的应用场景

比如说在某一台主机上安装 Redis，当这台主机发生宕机或者磁盘损坏时，就会导致服务不可用或者数据丢失，所以一般情况下我们会为一个 Redis 服务器设置多个从服务器以达到防止数据丢失问题，这种模式也可以实现读写分离，然后提升整个 Redis 对外的吞吐量，最后可以联合哨兵模式来提升系统的可用性以及扩展性，那么一旦牵涉到主从这种框架就会涉及到复制的问题，Redis 当中支持两种复制模式。

### 全量复制

是指主从服务器之间建立连接，从服务器发送 sync 命令向主服务器请求数据，主服务器通过 bgsave 生成 RDB 文件，并且将 RDB 文件传给从服务器，这个阶段又称为同步阶段，在这个阶段，主服务器可能会接收其他的写命令，这时候需要将缓存中的写命令也给到从服务器去执行，这个阶段也称为命令传播阶段，在 Redis2.8 版本之前复制的方式只支持全量同步，但全量同步 sync 命令效率较低并且比较耗资源，所以必须考虑另外一种复制方式，在 2.8 版本之后新增了一个增量复制，

### 增量复制

首先考虑一个问题：主从服务器之间什么时候需要进行数据复制？

1. 从服务器断线重连，断线期间有可能数据是不一样的
2. 新增节点，必须进行全量复制

是否进行增量复制，我们需要考虑从服务器复制了多少，首先可以按照主服务器的 ID 去判断，如果主服务器的 ID 变了，那么就需要进行全量复制，其次也需要偏移量来记录，主服务器和从服务器之间差距有多少，并且主服务器中维护了一个积压命令的缓冲区，如果偏移量在缓冲区范围内就进行增量复制。
